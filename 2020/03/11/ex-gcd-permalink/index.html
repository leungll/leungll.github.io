<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="robots" content="index, follow">

    <!-- Baidu Site SEO -->
    <meta name="baidu-site-verification" content="codeva-Fn6WoXLOMw" />
    <!-- <meta name="baidu-site-verification" content="codeva-mdLm33TTHY" /> -->

    <!-- Baidu analytics -->
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?1a364896f028f8093396007dc78eb0a0";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WF4EY3839B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WF4EY3839B');
    </script>

    <!-- Bing Site SEO -->
    <meta name="msvalidate.01" content="85648BC2E966622B7CC9FF6BCB04E326" />

    <!-- title -->
    
        <title>数论之扩展欧几里得，费马小定理，欧拉定理 + 求最小乘法逆元 | Lili Liang</title>
    
  
    <!-- Open graph -->
    <meta name="description" content="1 逆元定义 2 欧几里得算法（求最大公约数） 3 扩展欧几里得算法  3.1 预备知识 3.2 关于扩展欧几里得算法 3.3 模板 3.4 算法推导过程 3.5 利用拓展欧几里得算法求逆元   4 费马小定理  4.1 定义 4.2 模板   5 欧拉定理 6 RSA公钥密码经典例题  6.1 题目描述 6.2 分析 6.3 题解   References    前两天二刷了《模仿游戏》，A">
<meta property="og:type" content="article">
<meta property="og:title" content="数论之扩展欧几里得，费马小定理，欧拉定理 + 求最小乘法逆元">
<meta property="og:url" content="https://leungll.site/2020/03/11/ex-gcd-permalink/index.html">
<meta property="og:site_name" content="Lili Liang">
<meta property="og:description" content="1 逆元定义 2 欧几里得算法（求最大公约数） 3 扩展欧几里得算法  3.1 预备知识 3.2 关于扩展欧几里得算法 3.3 模板 3.4 算法推导过程 3.5 利用拓展欧几里得算法求逆元   4 费马小定理  4.1 定义 4.2 模板   5 欧拉定理 6 RSA公钥密码经典例题  6.1 题目描述 6.2 分析 6.3 题解   References    前两天二刷了《模仿游戏》，A">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/ex-gcd-01.png">
<meta property="article:published_time" content="2020-03-11T14:13:36.000Z">
<meta property="article:modified_time" content="2025-01-05T09:46:37.401Z">
<meta property="article:author" content="Lili Liang 梁莉莉">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="快速幂">
<meta property="article:tag" content="数论">
<meta property="article:tag" content="扩展欧几里得">
<meta property="article:tag" content="费马小定理">
<meta property="article:tag" content="乘法逆元">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/ex-gcd-01.png">

    <!-- Canonical -->
    
        <link rel="canonical" href="https://leungll.site/2020/03/11/ex-gcd-permalink/">
    

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/logo.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/logo.png">

    <!-- CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">


    <script>
        MathJax = {
          tex: {
            packages: ['base', 'ams'],
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true
          },
          options: {
            ignoreHtmlClass: "tex2jax_ignore",
            processHtmlClass: "tex2jax_process"
          }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lili Liang" type="application/atom+xml">
</head>

    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Lili Liang 梁莉莉</a>
    <!-- <div class="logo"><a href="/" title="Len"><img src="/img/logo.svg" alt="Len" aria-label="logo" height="20"></a></div> -->
        <ul class="nav">
            
            <li><a href="/">Blogs</a></li>
            
            <li><a href="/archives">Archives</a></li>
            
            <li><a href="/about">About</a></li>
            
        </ul>
    </a>
</div>

                
                <div class="post-main">
    
        <!-- Post Title -->
        <div class="post-main-title">
            数论之扩展欧几里得，费马小定理，欧拉定理 + 求最小乘法逆元
        </div>

        <!-- Post Meta Information -->
        <div class="post-meta">
            <!-- Show Creation Date -->
            Created: Mar 11, 2020 ｜ 

            <!-- Show Last Updated Date -->
            
                Last updated: Jan 5, 2025 ｜ 
            

            <!-- Show Post Categories -->
            
                <a href="/categories/%E7%AE%97%E6%B3%95/"># 算法</a>
            
        </div>

        <!-- Post Content -->
        <div class="post-md">
            <!-- toc -->
<ul>
<li><a href="#1-%E9%80%86%E5%85%83%E5%AE%9A%E4%B9%89">1 逆元定义</a></li>
<li><a href="#2-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">2 欧几里得算法（求最大公约数）</a></li>
<li><a href="#3-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">3 扩展欧几里得算法</a>
<ul>
<li><a href="#31-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">3.1 预备知识</a></li>
<li><a href="#32-%E5%85%B3%E4%BA%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">3.2 关于扩展欧几里得算法</a></li>
<li><a href="#33-%E6%A8%A1%E6%9D%BF">3.3 模板</a></li>
<li><a href="#34-%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B">3.4 算法推导过程</a></li>
<li><a href="#35-%E5%88%A9%E7%94%A8%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%B1%82%E9%80%86%E5%85%83">3.5 利用拓展欧几里得算法求逆元</a></li>
</ul>
</li>
<li><a href="#4-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">4 费马小定理</a>
<ul>
<li><a href="#41-%E5%AE%9A%E4%B9%89">4.1 定义</a></li>
<li><a href="#42-%E6%A8%A1%E6%9D%BF">4.2 模板</a></li>
</ul>
</li>
<li><a href="#5-%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">5 欧拉定理</a></li>
<li><a href="#6-rsa%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98">6 RSA公钥密码经典例题</a>
<ul>
<li><a href="#61-%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">6.1 题目描述</a></li>
<li><a href="#62-%E5%88%86%E6%9E%90">6.2 分析</a></li>
<li><a href="#63-%E9%A2%98%E8%A7%A3">6.3 题解</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
<!-- tocstop -->
<blockquote>
<p>前两天二刷了《模仿游戏》，Alan Turing 在二战中研制的图灵机破译了德军号称牢不可破的 Enigma 密码机。这部剧让我对计算机产生了一些新的理解，结合以前修过的密码学原理课程，因此想记录一下之前没掌握好的数论知识，并且以 RSA 公钥密码为例，解一道经典题。</p>
</blockquote>
<h2><span id="1-逆元定义">1 逆元定义</span></h2>
<blockquote>
<p>若 $a\ *\ x\ ≡\ 1\ (mod\ b)$ ，且 a 与 b 互斥，那么就能定义 x 为 a 的逆元，记为 $a^{-1}$，也可称为 x 为 a 的倒数。</p>
</blockquote>
<h2><span id="2-欧几里得算法求最大公约数">2 欧几里得算法（求最大公约数）</span></h2>
<blockquote>
<p>首先介绍古老而又强大的欧几里得算法（又称辗转相除法）：<br>
两个数 a 和 b 的<strong>最大公因子</strong>（greatest common divisior）是能整除它们两者的最大整数。欧几里德算法用于计算两个整数 a，b 的最大因子。记 <strong>gcd(a, b)</strong> 为自然数 a 与 b 的最大公因子。特别的，有 gcd(0, n) = 0，因为任何整数都能整除 0。</p>
</blockquote>
<p><strong>内容：</strong><br>
$$<br>
gcd(a, b) = \left{<br>
\begin{array}{ll}<br>
a, &amp; \text{if} \ b = 0 \<br>
gcd(b, a \mod b), &amp; \text{if} \ b \neq 0<br>
\end{array}<br>
\right.<br>
$$</p>
<p><strong>代码</strong>：</p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">int gcd(int a, int b)&#123;   
    return b == 0 ? a : gcd(b, a % b);     
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2><span id="3-扩展欧几里得算法">3 扩展欧几里得算法</span></h2>
<h3><span id="31-预备知识">3.1 预备知识</span></h3>
<p><strong>1. 取模运算</strong>：</p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">(a + b) % c = (a % c + b % c) % c
(a * b) % c = (a % c * b % c) % c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>取模运算对除法不成立，当要求 <strong>(a / b) % c</strong> 时，可转化为逆元来求：</p>
<p>$$<br>
(a,/,b),%,c,=,(a,<em>,b^{-1}),%,c,=,(a,%,c,,</em>,,b^{-1},%,c),%,c<br>
$$</p>
<p>这就是逆元的作用。</p>
<p><strong>2. 裴蜀定理：</strong></p>
<p>给予两个整数 a，b，必存在整数 x，y 使得 $$ax+by=gcd(a,,b)$$</p>
<p>即如若 $ax+by=c$ 有解，那么有 $gcd(a,,b),|,c$（c 一定是 $gcd(a,,b)$ 的若干倍）</p>
<p>特例：当 $c = 1$ 时，如果 $ax+by=1$ 有解，那么 $gcd(a,,b),=,1$</p>
<h3><span id="32-关于扩展欧几里得算法">3.2 关于扩展欧几里得算法</span></h3>
<ul>
<li>
<p><strong>扩展欧几里得算法</strong>（Extended Euclidean algorithm）是欧几里得算法的扩展。它可用来求解形如 $ax+by=c,(a,b,c,\in Z)$ 方程的一组整数解。</p>
</li>
<li>
<p>对于求解方程 $ax+by=c,(gcd(a,,b),|,c)$ ，只需求解出方程 $$ax+by=gcd(a,,b)$$ 的一组解，将 $x,y$ 分别乘上  $\frac {c}{gcd(a,b)}$ 即可得到方程 $ax+by=c,(gcd(a,,b),|,c)$ 的一组解。</p>
</li>
<li>
<p>扩展欧几里得算法可以用来计算模反元素(也叫模逆元)，而模反元素在 RSA 加密算法中有举足轻重的地位。</p>
</li>
</ul>
<h3><span id="33-模板">3.3 模板</span></h3>
<p>(思考了一下该先放模板，还是先放算法的证明过程，最后决定先放模板，然后就着模板理解算法的证明过程)</p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">ll ex_gcd(ll a, ll b, ll &x, ll &y)&#123;
    //标记1
    if(b == 0)&#123;
        x = 1, y = 0;
        return a;
    &#125;
    ll d = ex_gcd(b, a % b, x, y);
    ll temp = y;
    //标记2
    y = x - (a / b) * y;
    x = temp;
    //标记3
    return d;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="34-算法推导过程">3.4 算法推导过程</span></h3>
<blockquote>
<p>现有方程：<br>
$$<br>
ax+by=gcd(a,,b)<br>
$$<br>
记 <strong>ex_gcd(a, b, x, y)</strong> 为求解上述方程的函数，函数返回的是 $gcd(a,b)$ 的<strong>最大公约数</strong>(对应模板代码<code>标记3</code>），其中形参 $x,y$ 为<strong>引用参数</strong>(全局变量)，也是上述<strong>方程的解</strong>。</p>
</blockquote>
<ol>
<li>
<p>边界情况(对应模板代码<code>标记1</code>）：<br>
当 $b=0$ 时，方程为 $ax=gcd(a,0)$ ，解得<br>
$$<br>
\left{<br>
\begin{array}{l}<br>
x=1 \  y=0<br>
\end{array}<br>
\right.<br>
$$</p>
<p>此时 a 就是 $gcd(a,0)$ 的最大公约数，因此函数<strong>return a</strong>。</p>
</li>
<li>
<p>一般情况(对应模板代码<code>标记2</code>）：<br>
当 $b\neq0$ 时，有欧几里得算法</p>
<p>$$<br>
gcd(a,,b),=,gcd(b^\prime,,,a^\prime,%,b^\prime)<br>
$$</p>
<p>则有方程<br>
$$<br>
ax+by=gcd(a,,b)=gcd(b^\prime,,,a^\prime,%,b^\prime)<br>
$$</p>
<p>另外有等式（不是啥公式，一个运算技巧）：<br>
$$<br>
a,%,b=a-(a/b)*b<br>
$$</p>
<p>则方程可化为<br>
$$<br>
gcd(b^\prime,,,a^\prime,%,b^\prime)=b^\prime x^\prime+(a^\prime,%,b^\prime)y^\prime=b^\prime x^\prime+(a^\prime-(a^\prime/b^\prime)*b^\prime)y^\prime<br>
$$</p>
<p>上式化简得：<br>
$$<br>
b^\prime x^\prime+a^\prime y^\prime-(a^\prime / b^\prime)<em>b^\prime</em>y^\prime=a^\prime y^\prime+b^\prime*(x^\prime-a^\prime /,b^\prime*y^\prime)<br>
$$</p>
<p>于是可以得到关于方程解 $x,y$ 的递推关系：<br>
$$<br>
\left{<br>
\begin{array}{l}<br>
x=y^\prime \  y=x^\prime-a^\prime /,b^\prime*y^\prime<br>
\end{array}<br>
\right.<br>
$$</p>
</li>
<li>
<p>由此我们得到了边界条件以及递归式，即每次递归<code>ex_gcd(b, a mod b, x, y)</code>，稍加处理，即可求得方程 $ax+by=gcd(a,,b)$ 的一组解 $x,y$ 。</p>
</li>
</ol>
<h3><span id="35-利用拓展欧几里得算法求逆元">3.5 利用拓展欧几里得算法求逆元</span></h3>
<blockquote>
<p>那么问题来了，我们通过函数<code>ex_gcd(a, b, x, y)</code>，求得 $gcd(a,b)$（即最大公约数）的结果，以及一组方程解 $(x,y)$，对求逆元有什么作用？</p>
</blockquote>
<ol>
<li>
<p>根据逆元定义 $a,*,x,≡,1,(mod,b)$<br>
当我们求 $a$ 在 $mod,b$ 情况下的逆元时，假设逆元为 x ，即<br>
$$<br>
ax\equiv1(mod,b)<br>
$$</p>
<p>转化等式：<br>
$$<br>
ax\equiv1+by(,,(b * y)|(a *x),\ 即\ a * x\ 是\ b * y\ 的若干倍)<br>
$$</p>
<p>移项<br>
$$<br>
ax+by\equiv1<br>
$$</p>
<p>则最小的 $x$ 即为 $a$ 在 $mod,b$ 情况下的一个逆元。</p>
</li>
<li>
<p>由裴蜀定理：<br>
$$<br>
ax+by=gcd(a,,b)<br>
$$</p>
<p>当 $gcd(a,,b)=1$ 时，由扩展欧几里得函数<code>ex_gcd(a, b, x, y)</code>求得的方程解 $x$ 即为我们所求的<strong>最小乘法逆元</strong>。</p>
</li>
<li>
<p>因此下面代码中的<code>标记4</code>得到解释：</p>
</li>
</ol>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//拓展欧几里得算法
ll ex_gcd(ll a, ll b, ll &x, ll &y)&#123;
    //标记1
    if(b == 0)&#123;
        x = 1, y = 0;
        return a;
    &#125;
    ll d = ex_gcd(b, a % b, x, y);
    ll temp = y;
    //标记2
    y = x - (a / b) * y;
    x = temp;
    //标记3
    return d;
&#125;

//求a在mod下的逆元x
ll getInv(ll a, ll mod)&#123;
    ll x, y;
    ll d = ex_gcd(a, mod, x, y);
    //标记4
    return d == 1 ? (x + mod) % mod : -1;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当扩展欧几里得函数<code>ex_gcd(a, b, x, y)</code>返回的最大公约数 $d = 1$ 时，$x$ 即为 $a,mod,b$ 下的最小乘法逆元，<code>(x + mod) % mod</code>是为了将 $x$ 调整到 0 ~ (b - 1)的范围中；</li>
<li>当函数的返回值 $d\neq 1$ 时，即说明逆元不存在，返回 $-1$；</li>
<li>拓展欧几里得求逆元的<strong>时间复杂度</strong>：$O(logn)$；</li>
<li><strong>适用范围</strong>：只要存在逆元即可求，适用于个数不多但是 mod 很大的时候，也是<strong>最常见</strong>的一种求逆元的方法；</li>
</ul>
<h2><span id="4-费马小定理">4 费马小定理</span></h2>
<h3><span id="41-定义">4.1 定义</span></h3>
<blockquote>
<p>如果 $p$ 是一个质数，且整数 $a$ 不是 $p$ 的倍数，则有：$a^{p-1}\equiv1(mod,p)$</p>
</blockquote>
<ul>
<li>
<p>由公式得：<br>
$$<br>
a^{p-2},*,a\equiv1(mod,p)<br>
$$<br>
因此 $a^{p-2}$ 即为 $a$ 在 $mod,p$ 意义下的逆元。</p>
</li>
<li>
<p>而 $a^{p-2}$ 可用<strong>快速幂</strong>求解（关于快速幂原理可在此博客了解：<a href="https://leungll.site/2021/05/24/ksm-permalink/">快速幂 &amp; 快速乘原理讲解（模板）</a>）</p>
</li>
</ul>
<h3><span id="42-模板">4.2 模板</span></h3>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">//快速幂
ll ksm(ll a, ll p, ll mod) &#123;
    ll ans = 1, base = a % mod;
    while(p) &#123;
        if(p & 1) &#123;
            ans = (ans * base) % mod;
        &#125;
        base = (base * base) % mod;
        p >>= 1;
    &#125;
    return ans;
&#125;
//求逆元
ll getInv(ll a, ll mod)&#123;
    return ksm(a, p - 2, mod);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>费马小定理求逆元的<strong>时间复杂度</strong>：$O(logmod)$</li>
<li><strong>适用范围</strong>：根据费马小定理，$mod,p$ 为<strong>质数</strong>时适用。并且比扩展欧几里得算法好写一些。</li>
</ul>
<h2><span id="5-欧拉定理">5 欧拉定理</span></h2>
<blockquote>
<p>欧拉定理（也称费马-欧拉定理），是一个关于同余的性质。欧拉定理表明，若 $p,,a$ 为正整数，且 $p,,a$ 互质，则：<br>
$$<br>
a^{\varphi (p)}\equiv1(mod\ p)<br>
$$</p>
</blockquote>
<ul>
<li>
<p>由公式得：<br>
$$<br>
a^{\varphi (p)-1},*,a\equiv1(mod,p)<br>
$$<br>
因此 $a^{\varphi (p)-1}$ 即为 $a$ 在 $mod,p$ 意义下的逆元。</p>
</li>
<li>
<p>可以看到，费马小定理是欧拉定理的特例，当 $p$ 为质数时，$\varphi (p)=,p-1$，$\varphi (p)-1=,p-2$</p>
</li>
<li>
<p>欧拉定理比费马小定理适用范围更广，因为模数 $p$ 可以不是质数。</p>
</li>
<li>
<p>一般很少有人直接用欧拉定理求逆元（偷个懒，板子就不贴上来了）</p>
</li>
</ul>
<h2><span id="6-rsa公钥密码经典例题">6 RSA公钥密码经典例题</span></h2>
<blockquote>
<p>说了这么多<s>废话</s> （正经话），终于可以开始做题了。</p>
</blockquote>
<h3><span id="61-题目描述">6.1 题目描述</span></h3>
<blockquote>
<p>RSA 是一种经典的加密算法。它的基本加密过程如下：<br>
首先生成两个质数 $p, q$，令 $n = p * q$，设 $d$ 与 $(p - 1) * (q - 1)$ 互质，则可找到 $e$ 使得 $d * e$ 除 $(p - 1) * (q - 1)$ 的余数为 1。<br>
$n, d, e$ 组成了私钥，$n, d$ 组成了公钥。<br>
当使用公钥加密一个整数 $X$ 时(小于 $n$ )，计算 $C = X^{d},mod,n$ ，则 $C$ 是加密后的密文。<br>
当收到密文 $C$ 时，可使用私钥解开，计算公式为 $X=C^{e},mod,n$。<br>
例如，当 $p = 5, q = 11, d = 3$ 时，$n = 55,,e = 27$。<br>
若加密数字 $24$ ，得 $24^{3},mod,55 = 19$ 。<br>
解密数字 $19$ ，得 $19^{27},mod,55 = 24$ 。<br>
现在你知道公钥中 $n = 1001733993063167141, ,d = 212353$，同时你截获了别人发送的密文 $C = 20190324$ 。请问：原文是多少?</p>
</blockquote>
<h3><span id="62-分析">6.2 分析</span></h3>
<ul>
<li>
<p>由题目已知 $n,,d,,C,$ ，根据解密公式 $X=C^{e},mod,n$，只需求得私钥 $e$ ，即可解得原文 $X$。</p>
</li>
<li>
<p>根据题目信息：$d$ 与 $(p-1)*(q-1)$ 互质，则可找到 $e$ 使得 $d * e$ 除 $(p - 1) * (q - 1)$ 的余数为 1，翻译成 <s>人话</s>（公式）就是：<br>
$$<br>
d * e\equiv1(mod,,(p - 1) * (q - 1),)<br>
$$</p>
</li>
<li>
<p>设 $k = (p - 1) * (q - 1)$，即：<br>
$$<br>
d,*,e\equiv1(mod,k)<br>
$$</p>
</li>
<li>
<p>由上述公式可得 <strong>$e$ 即为 $d$ 在 $mod,k$意思下的乘法逆元</strong>。在这里我们用<strong>拓展欧几里得算法</strong>求解。</p>
</li>
<li>
<p>最后一个问题：关于 $k$ 即$(p - 1) * (q - 1)$应该如何求解。这里用到<strong>质因数分解</strong>，由题目可知 $n = p * q$，且 $p,,q$ 均为质数。我们先找到一个小于 $n$ 的质数 $p$，再用 $n / p$ 即可得到 $q$ 。</p>
</li>
</ul>
<h3><span id="63-题解">6.3 题解</span></h3>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;

ll n = 1001733993063167141, d = 212353, c = 20190324;

//判断质数 
ll isPrime(ll x)&#123;
    for(ll i = 2;i <= 1 x;i++)&#123; if(x % i="=" 0)&#123; return i; &#125; 扩展欧几里得算法 ll ex_gcd(ll a, b, &x, &y)&#123; if(b="=" x="1," y="0;" a; d="ex_gcd(b," a x, y); temp="y;" - (a b) * y; d; 求a在mod下的乘法逆元x getinv(ll mod)&#123; mod, ? (x + mod) mod : -1; 快速乘 ksc(ll &#123; ans="0;" while(b) & 1) a) mod; b>>= 1;
    &#125;
    return ans;
&#125;

//快速幂 
ll ksm(ll a, ll b, ll mod) &#123;
    ll ans = 1, base = a;
    while(b) &#123;
        if(b & 1) &#123;
            ans = ksc(ans, base, mod) % mod;
        &#125;
        base = ksc(base, base, mod) % mod;
        b >>= 1;
    &#125;
    return ans;
&#125;

int main()&#123;
    ll p = isPrime(n), q = n / p, k = (p - 1) * (q - 1);
    ll e = getInv(d, k);
    //	printf("e is %lld\n", e);
    ll x = ksm(c, e, n);
    printf("%lld\n", x);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></=></cstdio></iostream></code></pre>
<ul>
<li>
<p>注意到题目中的数据实在是太大了，单独用快速幂求解 $X=C^{e},mod,n$ 会导致数据溢出，因此我们对快速幂优化了一下（用快速乘求每次 $a$ 的余数，再快速幂对余数进行幂运算），达到模拟大数模幂运算的效果。</p>
</li>
<li>
<p>相关博客可参考：<a href="https://leungll.site/2020/03/12/ksm-ksc-permalink/">快速幂 &amp; 快速乘取模（模拟大数模幂运算，解决乘法爆long long问题）</a></p>
</li>
</ul>
<p>运算结果：<br>
<img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/ex-gcd-01.png" alt="ex-gcd-01"></p>
<ul>
<li>答案：<code>579706994112328949</code></li>
<li>RSA 是非对称加密算法，基于大数分解，题目只是模拟了一下 RSA 解密的过程，可以看到当 $n = 1001733993063167141$ 时，我的电脑跑出结果就花了十几秒。而真正 RSA 密码中，$n$ 一般而言可达到 $1024\sim2048$ 比特，普通的计算机跑出结果要十年左右，量子计算机需一周。</li>
</ul>
<h2><span id="references">References</span></h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.sengxian.com/algorithms/gcd-extgcd">欧几里德算法与扩展欧几里德算法</a></li>
</ul>

        </div>
    

    <!-- Post Tags -->
    
        <div class="post-meta">
            Tags:
            
                <a href="/tags/C-C/"> / C/C++</a>
            
                <a href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"> / 快速幂</a>
            
                <a href="/tags/%E6%95%B0%E8%AE%BA/"> / 数论</a>
            
                <a href="/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"> / 扩展欧几里得</a>
            
                <a href="/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"> / 费马小定理</a>
            
                <a href="/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"> / 乘法逆元</a>
            
        </div>
    
</div>
                <div class="footer">
    <span>Copyright © 2025 Lili Liang</span>
    <span>Build with <a target="_blank" rel="noopener" href="https://github.com/LenChou95/hexo-theme-ZenMind">ZenMind</a></span>
</div>

<!-- Copy Code Funciton -->
<script>
    document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre').forEach((pre) => {
            const button = document.createElement('button');
            button.innerText = 'Copy';
            button.className = 'copy-button';

            button.addEventListener('click', () => {
            const codeLines = pre.querySelectorAll('.hljs-ln-code');
            const codeContent = Array.from(codeLines)
                .map(line => line.textContent)
                .join('\n');

            navigator.clipboard.writeText(codeContent).then(() => {
                button.innerText = '√ Copied!';
                setTimeout(() => {
                button.innerText = 'Copy';
                }, 3000);
            }).catch(err => {
                console.error('Copy failed: ', err);
                alert('Unable to copy code, please check browser permissions!');
            });
            });

            pre.appendChild(button);
        });
    });
</script>

<!-- Change Code Style -->

<link rel="stylesheet" href="/css/a11y-dark.min.css">

<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css"> -->


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>