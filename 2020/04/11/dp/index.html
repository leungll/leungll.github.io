<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="robots" content="index, follow">

    <!-- Baidu Site SEO -->
    <meta name="baidu-site-verification" content="codeva-Fn6WoXLOMw" />
    <!-- <meta name="baidu-site-verification" content="codeva-mdLm33TTHY" /> -->

    <!-- Baidu analytics -->
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?1a364896f028f8093396007dc78eb0a0";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WF4EY3839B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WF4EY3839B');
    </script>

    <!-- Bing Site SEO -->
    <meta name="msvalidate.01" content="85648BC2E966622B7CC9FF6BCB04E326" />

    <!-- title -->
    
        <title>算法之动态规划篇 | Lili Liang</title>
    
  
    <!-- Open graph -->
    <meta name="description" content="1 dp基本性质 2 装箱问题 3 开心的金明(0&#x2F;1背包) 4 数的划分(分类讨论，dfs实现） 5 摆动序列(dfs实现） 6 传球游戏(环形dp) 7 方格取数(多线程dp） 8 K好数   1 dp基本性质   最优子结构  当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。 在动态规划算法中，利用问题的">
<meta property="og:type" content="article">
<meta property="og:title" content="算法之动态规划篇">
<meta property="og:url" content="https://leungll.site/2020/04/11/dp/index.html">
<meta property="og:site_name" content="Lili Liang">
<meta property="og:description" content="1 dp基本性质 2 装箱问题 3 开心的金明(0&#x2F;1背包) 4 数的划分(分类讨论，dfs实现） 5 摆动序列(dfs实现） 6 传球游戏(环形dp) 7 方格取数(多线程dp） 8 K好数   1 dp基本性质   最优子结构  当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。 在动态规划算法中，利用问题的">
<meta property="og:locale">
<meta property="article:published_time" content="2020-04-11T16:35:20.000Z">
<meta property="article:modified_time" content="2025-01-05T07:08:02.133Z">
<meta property="article:author" content="Lili Liang 梁莉莉">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="dp">
<meta name="twitter:card" content="summary">

    <!-- Canonical -->
    
        <link rel="canonical" href="https://leungll.site/2020/04/11/dp/">
    

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/logo.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/logo.png">

    <!-- CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">


    <script>
        MathJax = {
          tex: {
            packages: ['base', 'ams'],
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true
          },
          options: {
            ignoreHtmlClass: "tex2jax_ignore",
            processHtmlClass: "tex2jax_process"
          }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Lili Liang" type="application/atom+xml">
</head>

    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Lili Liang 梁莉莉</a>
    <!-- <div class="logo"><a href="/" title="Len"><img src="/img/logo.svg" alt="Len" aria-label="logo" height="20"></a></div> -->
        <ul class="nav">
            
            <li><a href="/">Blogs</a></li>
            
            <li><a href="/archives">Archives</a></li>
            
            <li><a href="/about">About</a></li>
            
        </ul>
    </a>
</div>

                
                <div class="post-main">
    
        <!-- Post Title -->
        <div class="post-main-title">
            算法之动态规划篇
        </div>

        <!-- Post Meta Information -->
        <div class="post-meta">
            <!-- Show Creation Date -->
            Created: Apr 12, 2020 ｜ 

            <!-- Show Last Updated Date -->
            
                Last updated: Jan 5, 2025 ｜ 
            

            <!-- Show Post Categories -->
            
                <a href="/categories/%E7%AE%97%E6%B3%95/"># 算法</a>
            
        </div>

        <!-- Post Content -->
        <div class="post-md">
            <!-- toc -->
<ul>
<li><a href="#1-dp%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8">1 dp基本性质</a></li>
<li><a href="#2-%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98">2 装箱问题</a></li>
<li><a href="#3-%E5%BC%80%E5%BF%83%E7%9A%84%E9%87%91%E6%98%8E01%E8%83%8C%E5%8C%85">3 开心的金明(0/1背包)</a></li>
<li><a href="#4-%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BAdfs%E5%AE%9E%E7%8E%B0">4 数的划分(分类讨论，dfs实现）</a></li>
<li><a href="#5-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97dfs%E5%AE%9E%E7%8E%B0">5 摆动序列(dfs实现）</a></li>
<li><a href="#6-%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%BD%A2dp">6 传球游戏(环形dp)</a></li>
<li><a href="#7-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E5%A4%9A%E7%BA%BF%E7%A8%8Bdp">7 方格取数(多线程dp）</a></li>
<li><a href="#8-k%E5%A5%BD%E6%95%B0">8 K好数</a></li>
</ul>
<!-- tocstop -->
<h2><span id="1-dp基本性质">1 dp基本性质</span></h2>
<ul>
<li>
<p><strong>最优子结构</strong></p>
<ul>
<li>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的<strong>最优子结构性质</strong>提供了该问题可用动态规划算法求解的重要线索。</li>
<li>在动态规划算法中，利用问题的最优子结构性质，以<strong>自底向上</strong>的方式递归地从<strong>子问题</strong>的最优解逐步构造出<strong>整个问题的最优解</strong>。</li>
</ul>
</li>
<li>
<p><strong>重叠子问题</strong></p>
<ul>
<li>子问题之间是不独立的，一个子问题在下一阶段决策中可能被<strong>多次使用</strong>。对每个子问题只解一次，而后将其保存在一个表格中，当再次需要的时候，只是简单的用<strong>常数时间</strong>查看一下结果。</li>
</ul>
</li>
<li>
<p><strong>无后效性</strong></p>
<ul>
<li>即某阶段状态一旦确定，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，<strong>只与当前状态有关</strong>。</li>
</ul>
</li>
</ul>
<h2><span id="2-装箱问题">2 装箱问题</span></h2>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problem.page?gpid=T83">http://lx.lanqiao.cn/problem.page?gpid=T83</a></p>
<p><strong>题目大意</strong>：</p>
<blockquote>
<p>有一个箱子容量为 V（正整数，0 ＜＝ V ＜＝ 20000），同时有 n 个物品（0 ＜ n ＜＝ 30），每个物品有一个体积（正整数）。<br>
要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p>
</blockquote>
<p><strong>解题思路</strong>：</p>
<p>最经典的 $dp$ 问题，直接上手</p>
<ul>
<li>$dp[j]$：当体积为 $j$ 时，最大填充为 $dp[j]$</li>
<li>$dp$ 方程：<br>
$$<br>
dp[j] = max(dp[j], dp[, j - w[i] ,] + w[i])<br>
$$</li>
</ul>
<p><strong>题解</strong>：</p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>
#include <cstdio>
using namespace std;

const int maxn = 20010;
//dp[j]：当体积为j时，最大填充为dp[j] 
int dp[maxn], w[35];

int main()&#123;
    // freopen("input.txt", "r", stdin);
    int v, n;
    cin >> v >> n;
    for(int i = 0;i < n;i++)&#123;
        cin >> w[i];
    &#125;
    //n个物品 
    for(int i = 0;i < n;i++)&#123;
        //总体积为v 
        for(int j = v;j >= w[i];j--)&#123;
            dp[j] = max(dp[j], dp[j - w[i]] + w[i]);
        &#125;
    &#125;
    printf("%d\n", v - dp[v]);
    return 0;
&#125;
/*
24
6
8
3
12
7
9
7

0
*/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></cstdio></iostream></code></pre>
<h2><span id="3-开心的金明01背包">3 开心的金明(0/1背包)</span></h2>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problem.page?gpid=T93">http://lx.lanqiao.cn/problem.page?gpid=T93</a></p>
<p><strong>题目大意</strong>：</p>
<blockquote>
<p>在不超过 $N$ 元（可以等于 $N$ 元）的前提 下，使每件物品的价格与重要度的乘积的总和最大。</p>
</blockquote>
<p><strong>解题思路</strong>：</p>
<p>约定，$dp[i][j]$ 表示判定了 $i$ 件物品，剩余钱数为 $j$ 时，每件物品的价格与重要度的乘积的总和最大。</p>
<ul>
<li>
<p>典型的 <strong>$0/1$ 背包</strong>问题</p>
</li>
<li>
<p>$dp$ 方程：<br>
$$<br>
dp[i][j] = max( dp[i - 1][j], ,dp[i - 1][j - v] + v * p)<br>
$$<br>
其中，$v$ 表示物品的价格，$p$ 表示该物品的重要度。</p>
</li>
</ul>
<p><strong>题解</strong>：</p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>
#include <cstdio>
using namespace std;

const int maxn = 30005;
//dp[i][j]表示判定了i件物品，剩余钱数为j时，每件物品的价格与重要度的乘积的总和最大
int dp[30][maxn] = &#123;0&#125;;

int main()&#123;
    int n, m;
    cin >> n >> m;
    //物品件数
    for(int i = 1;i <= m;i++)&#123; int v, p; cin>> v >> p;
        //总钱数
        for(int j = 1;j <= n;j++)&#123; if(j>= v)&#123;
                dp[i][j] = max( dp[i - 1][j], dp[i - 1][j - v] + v * p);
            &#125;else&#123;
                dp[i][j] = dp[i - 1][j];
            &#125;
        &#125;
    &#125;
    printf("%d\n", dp[m][n]);
    return 0;
&#125;
/*
1000 5
800 2
400 5
300 5
400 3
200 2

3900
*/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></=></=></cstdio></iostream></code></pre>
<h2><span id="4-数的划分分类讨论dfs实现">4 数的划分(分类讨论，dfs实现）</span></h2>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problem.page?gpid=T84">http://lx.lanqiao.cn/problem.page?gpid=T84</a></p>
<p><strong>题目大意：</strong></p>
<blockquote>
<p>将整数 n 分成 k 份，且每份不能为空，任意两份不能相同(不考虑顺序)。<br>
例如：n = 7，k = 3，下面三种分法被认为是相同的。<br>
1，1，5; 1，5，1; 5，1，1;<br>
问有多少种不同的分法。</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p>考虑四种情况：</p>
<ul>
<li>至少存在一个 $1$ 的情况：总数 $- 1$， 个数 $- 1$</li>
<li>不存在 $1$ 的情况：每个数分别 $-1$ ，则总数 $-(k*1)$ ，个数不变</li>
<li>当 $n=k$ 或 $k=1$ 时，只能有 $1$ 种划分方法，边界条件，返回 $1$</li>
<li>另外当 $n&lt;k$ 时，无法划分，此时返回 $0$</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>
#include <cstdio>
using namespace std;

int dfs(int n, int k)&#123;
    if(n == k || k == 1)&#123;
        return 1;
    &#125; 
    if(n < k)&#123;
        return 0;
    &#125;
    //至少存在一个1的情况：总数 - 1， 个数 - 1
    //一定不存在1的情况： k个数均≥2，则每个数都 - 1，总数 - k * 1，个数不变 
    return dfs(n - 1, k - 1) + dfs(n - k, k);
&#125;

int main()&#123;
    int n, k;
    cin >> n >> k;
    printf("%d\n", dfs(n, k));
    return 0;
&#125;
/*
7 3

4
*/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></cstdio></iostream></code></pre>
<h2><span id="5-摆动序列dfs实现">5 摆动序列(dfs实现）</span></h2>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problem.page?gpid=T44">http://lx.lanqiao.cn/problem.page?gpid=T44</a></p>
<p><strong>题目大意：</strong></p>
<blockquote>
<p>如果一个序列满足下面的性质，我们就将它称为摆动序列：</p>
<ul>
<li>
<ol>
<li>序列中的所有数都是不大于k的正整数；</li>
</ol>
</li>
<li>
<ol start="2">
<li>序列中至少有两个数；</li>
</ol>
</li>
<li>
<ol start="3">
<li>序列中的数两两不相等；</li>
</ol>
</li>
<li>
<ol start="4">
<li>如果第 i – 1 个数比第 i – 2 个数大，则第 i 个数比第 i – 2 个数小；如果第 i – 1 个数比第 i – 2 个数小，则第 i 个数比第 i – 2 个数大。</li>
</ol>
</li>
</ul>
<p>比如，当 k = 3 时，有下面几个这样的序列：</p>
<pre><code>1 2
1 3
2 1
2 1 3
2 3
2 3 1
3 1
3 2
</code></pre>
<p>一共有 8 种，给定 k ，请求出满足上面要求的序列的个数。</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<ul>
<li>本题用 $dfs$ 实现，其中条件 $1$ 与条件 $2$ 很容易满足。</li>
<li>条件 $3$ 与条件 $4$ ，用下列方程即可满足：<br>
$$<br>
(arr[x - 2] - arr[x - 3]) * (arr[x - 1] - arr[x - 3]) &lt; 0<br>
$$</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int maxn = 30;
int arr[maxn], vis[maxn];
int ans = 0, n;

void dfs(int x)&#123;
    if(x > 1)&#123;
        if(x == 2)&#123;
            ans++;
        //公式满足条件3与条件4 
        &#125;else if( (arr[x - 2] - arr[x - 3]) * (arr[x - 1] - arr[x - 3]) < 0)&#123;
            ans++;
        &#125;else&#123;
            return;
        &#125;
    &#125;
    for(int i = 1;i <= n;i++)&#123; if(!vis[i])&#123; vis[i]="1;" arr[x]="i;" dfs(x + 1); &#125; int main()&#123; memset(vis, 0, sizeof(vis)); cin>> n;
    dfs(0);
    printf("%d", ans);
    return 0;
&#125;
/*
3

8
*/
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></=></cstring></cstdio></iostream></code></pre>
<h2><span id="6-传球游戏环形dp">6 传球游戏(环形dp)</span></h2>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problem.page?gpid=T97">http://lx.lanqiao.cn/problem.page?gpid=T97</a></p>
<p><strong>题目大意：</strong></p>
<blockquote>
<p>有 $n$ 个同学围成一圈，小蛮传了 $m$ 次球后，球又回到自己手中，问有多少种传球方法？</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p>约定，$dp[i][j]$ 表示传了 $i$ 次球，到第 $j$ 个人手上的传球方法。</p>
<ul>
<li>因为是环形传球，因此需要考虑两个边界，第 $1$ 个人和第 $n$ 个人的情况。</li>
<li>当前同学的传球次数，为左右同学(传了 $i-1$ 次球)的传球方法相加<br>
$$<br>
dp[i][j] = dp[i - 1][x] + dp[i - 1][y]<br>
$$<br>
其中 $x=j-1,y=j+1$</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>
#include <cstdio>
using namespace std;

const int maxn = 40;
//dp[i][j]表示传了i次球，到第j个人的次数 
int dp[maxn][maxn] = &#123;0&#125;;

int main()&#123;
    int n, m;
    cin >> n >> m;
    //传了0次球，到第一个人的次数，自然为1 
    dp[0][1] = 1;
    for(int i = 1;i <= 2 3 m;i++)&#123; for(int j="1;j" <="n;j++)&#123;" int x="j" - 1, y="j" + 1; 考虑第1个人的情况 if(j="=" 1)&#123; &#125; 考虑第n个人的情况 n)&#123; 当前的情况等于左右传了i 1次球的情况相加 dp[i][j]="dp[i" 1][x] dp[i 1][y]; printf("%d\n", dp[m][1]); return 0; * <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></=></cstdio></iostream></code></pre>
<h2><span id="7-方格取数多线程dp">7 方格取数(多线程dp）</span></h2>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problem.page?gpid=T79">http://lx.lanqiao.cn/problem.page?gpid=T79</a></p>
<p><strong>题目大意：</strong></p>
<blockquote>
<p>设有 N * N 的方格图(N &lt;= 10)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。<br>
某人从图的左上角的 A 点(1, 1)出发，可以向下行走，也可以向右走，直到到达右下角的 B 点(N, N)。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0 ）。<br>
此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<ul>
<li>可模拟两个人同时从 $(1,1)$ 走到 $(N,N)$</li>
<li>$dp$ 方程：<br>
$$<br>
dp[x1][x2][y1][y2] = max(dp[x1 - 1][y1][x2 - 1][y2],<br>
$$</li>
</ul>
<p>$$<br>
dp[x1][y1 - 1][x2][y2 - 1],<br>
$$</p>
<p>$$<br>
dp[x1 - 1][y1][x2][y2 - 1],<br>
$$</p>
<p>$$<br>
dp[x1][y1 - 1][x2 - 1][y2])<br>
$$</p>
<ul>
<li>考虑两人走到同一点的特殊情况，只能加一次权值。</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">/*
模拟两个人同时从(1,1)走到(N,N)，
转移方程:dp[x1][x2][y1][y2] = max(dp[x1 - 1][y1][x2 - 1][y2], 
                                 dp[x1][y1 - 1][x2][y2 - 1], 
                                 dp[x1 - 1][y1][x2][y2 - 1], 
                                 dp[x1][y1 - 1][x2 - 1][y2]) 
考虑两人走到同一点的特殊情况，只能加一次权值。 
*/
#include <iostream>
#include <cstdio>
using namespace std;

const int maxn = 20;
int g[maxn][maxn] = &#123;0&#125;, dp[maxn][maxn][maxn][maxn] = &#123;0&#125;;

int main() &#123;
    // freopen("input.txt", "r", stdin);
    int n;
    cin >> n;
    while(true)&#123;
        int x, y, value;
        cin >> x >> y >> value;
        if(x == 0 && y == 0 && value == 0)&#123;
            break;
        &#125;
        g[x][y] = value;
    &#125;
    for(int x1 = 1;x1 <= 0 2 3 4 5 6 7 8 13 14 15 21 67 n;x1++)&#123; for(int y1="1;y1" <="n;y1++)&#123;" x2="1;x2" y2="1;y2" int temp="max(dp[x1" - 1][y1][x2 1][y2], dp[x1][y1 1][x2][y2 1]); dp[x1 1][y1][x2][y2 1][x2 1][y2]); if(x1="=" && y2)&#123; dp[x1][y1][x2][y2]="temp" + g[x1][y1]; &#125;else&#123; g[x1][y1] g[x2][y2]; &#125; printf("%d\n", dp[n][n][n][n]); return 0; * <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></=></cstdio></iostream></code></pre>
<h2><span id="8-k好数">8 K好数</span></h2>
<p><strong>题目链接：</strong><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problem.page?gpid=T13">http://lx.lanqiao.cn/problem.page?gpid=T13</a></p>
<p><strong>题目大意：</strong></p>
<blockquote>
<p>$K$ 好数定义：一个自然数 $N$ 的 $K$进制表示中任意的相邻的两位都不是相邻的数字。求 $L$ 位 $K$ 进制数中 $K$ 好数的数目。输出它对 $1000000007$ 取模后的值。</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p>我们约定，$dp[i][j]$ 表示长度为 $i$ ，以 $j$ 开头的 $K$ 好数个数。</p>
<ul>
<li>
<p>$K$ 好数中<strong>除开头外</strong>，每位数的取值为：$0 \sim K-1$；</p>
</li>
<li>
<p>以 $K=3，L=3$ 为例：<br>
$$ans = dp[3][0]+dp[3][1]+dp[3][2]$$<br>
其中 $dp[3][0]=dp[2][0]+dp[2][2]$<br>
   $dp[3][1]=dp[2][1]$<br>
   $dp[3][2]=dp[2][2]+dp[2][0]$</p>
</li>
<li>
<p>以此类推<strong>长度为 $2$ ，长度为 $1$</strong> 的情况；</p>
</li>
<li>
<p>因此可推出 $dp$ 方程：<br>
$$dp[i][j]=dp[i][j]+dp[i-1][x]$$<br>
其中 $x$ 取值为 $0 \sim K-1$</p>
</li>
<li>
<p>另外要注意，$K$ 好数开头不能为 $0$ ；</p>
</li>
</ul>
<p><strong>题解：</strong></p>
<pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <iostream>
#include <cstdio>
using namespace std;

#define MOD 1000000007

const int maxn = 105;
//dp[i][j]表示长度为i，以j开头的K好数个数 
int dp[maxn][maxn];

int main()&#123;
    int k, l;
    cin >> k >> l;
    //dp[1][i]表示长度为1，以i开头的K好数个数，此时个数均为 1 
    for(int i = 0;i < k;i++)&#123;
        dp[1][i] = 1;
    &#125;
    //长度由2 → l 
    for(int i = 2;i <= 1 2 4 7 l;i++)&#123; 表示以j开头的个数，因为是k进制，所以k的范围为0 ~ k - for(int j="0;j" < k;j++)&#123; 枚举以j为开头时的所有情况 x="0;x" k;x++)&#123; 符号k好数要求的数 if(x !="j" + && 1)&#123; dp方程 dp[i][j] 1][x]; 注意取模 %="MOD;" &#125; int ans="0;" 开头不能为o,所以开头i的范围为1 i="1;i" k;i++)&#123; printf("%d\n", ans); return 0; * <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></=></cstdio></iostream></code></pre>

        </div>
    

    <!-- Post Tags -->
    
        <div class="post-meta">
            Tags:
            
                <a href="/tags/C-C/"> / C/C++</a>
            
                <a href="/tags/dp/"> / dp</a>
            
        </div>
    
</div>
                <div class="footer">
    <span>Copyright © 2025 Lili Liang</span>
    <span>Build with <a target="_blank" rel="noopener" href="https://github.com/LenChou95/hexo-theme-ZenMind">ZenMind</a></span>
</div>

<!-- Copy Code Funciton -->
<script>
    document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre').forEach((pre) => {
            const button = document.createElement('button');
            button.innerText = 'Copy';
            button.className = 'copy-button';

            button.addEventListener('click', () => {
            const codeLines = pre.querySelectorAll('.hljs-ln-code');
            const codeContent = Array.from(codeLines)
                .map(line => line.textContent)
                .join('\n');

            navigator.clipboard.writeText(codeContent).then(() => {
                button.innerText = '√ Copied!';
                setTimeout(() => {
                button.innerText = 'Copy';
                }, 3000);
            }).catch(err => {
                console.error('Copy failed: ', err);
                alert('Unable to copy code, please check browser permissions!');
            });
            });

            pre.appendChild(button);
        });
    });
</script>

<!-- Change Code Style -->

<link rel="stylesheet" href="/css/a11y-dark.min.css">

<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css"> -->


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>