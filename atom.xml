<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lili Liang</title>
  
  
  <link href="https://leungll.site/atom.xml" rel="self"/>
  
  <link href="https://leungll.site/"/>
  <updated>2025-01-05T10:18:46.719Z</updated>
  <id>https://leungll.site/</id>
  
  <author>
    <name>Lili Liang 梁莉莉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>What&#39;s the difference between index(a, b, c) and index(b, c, a) in Range Query?</title>
    <link href="https://leungll.site/2025/01/04/index-range-query/"/>
    <id>https://leungll.site/2025/01/04/index-range-query/</id>
    <published>2025-01-04T13:57:03.000Z</published>
    <updated>2025-01-05T10:18:46.719Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#scenario-how-would-you-index-this-query">Scenario: How Would You Index This Query?</a></li><li><a href="#understanding-multi-filed-indexing">Understanding Multi-Filed Indexing</a></li><li><a href="#how-does-index-order-affect-range-query">How Does Index Order Affect Range Query?</a><ul><li><a href="#case-1-using-indexa-b-c">Case 1: Using INDEX(a, b, c)</a></li><li><a href="#case-2-using-indexb-c-a">Case 2: Using INDEX(b, c, a)</a></li></ul></li><li><a href="#tips-how-to-choose-the-right-index-order">Tips: How to Choose the Right Index Order?</a></li></ul><!-- tocstop --><h2><span id="scenario-how-would-you-index-this-query">Scenario: How Would You Index This Query?</span></h2><p>Image you have a table, and you need to optimize the following query:</p><div class="highlight"><pre class="code"><code><span class="hljs-attribute">SELECT</span> * FROM my_table WHERE a &gt;= <span class="hljs-number">1</span> AND b = <span class="hljs-number">1</span> AND c = <span class="hljs-number">1</span>;</code></pre></div><p>At first glance, you might think adding a multi-field index like <code>INDEX(a, b, c)</code> will solve the problem. But is that really the best choice?</p><h2><span id="understanding-multi-filed-indexing">Understanding Multi-Filed Indexing</span></h2><p>A multi-field index (also called a composite index) is an index that covers more than one column. For example:</p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_abc <span class="hljs-keyword">ON</span> my_table (a, b, c);</code></pre></div><p>This means the table is sorted in <u><strong>lexicographical order</strong></u> by:</p><ol><li>Column <code>a</code> first.</li><li>Then by <code>b</code> within rows where <code>a</code> is the same.</li><li>Finally by <code>c</code> within rows where both <code>a</code> and <code>b</code> are the same.</li></ol><p><u>But how does the order of column in an index affect performance in <strong>range query</strong> like <code>a &gt;= 1</code> ?</u></p><h2><span id="how-does-index-order-affect-range-query">How Does Index Order Affect Range Query?</span></h2><p>Let’s compare two different multi-field indexes:</p><div class="highlight"><pre class="code"><code><span class="hljs-constructor">INDEX(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>, <span class="hljs-params">c</span>)</span><span class="hljs-constructor">INDEX(<span class="hljs-params">b</span>, <span class="hljs-params">c</span>, <span class="hljs-params">a</span>)</span></code></pre></div><p>And we will analyze their performance on this query:</p><div class="highlight"><pre class="code"><code><span class="hljs-attribute">SELECT</span> * FROM my_table WHERE a &gt;= <span class="hljs-number">1</span> AND b = <span class="hljs-number">1</span> AND c = <span class="hljs-number">1</span>;</code></pre></div><h3><span id="case-1-using-indexa-b-c">Case 1: Using INDEX(a, b, c)</span></h3><p>With <code>INDEX(a, b, c)</code>, the query looks like this:</p><div class="highlight"><pre class="code"><code><span class="hljs-attribute">SELECT</span> * FROM my_table WHERE a &gt;= <span class="hljs-number">1</span> AND b = <span class="hljs-number">1</span> AND c = <span class="hljs-number">1</span>;</code></pre></div><p>Here’s how MySQL processes it:</p><ol><li>The database first finds <strong>rows where <code>a &gt;= 1</code></strong>;</li><li>However, because <code>a</code> is a range condition, the database cannot use the remaining columns (<code>b</code> and <code>c</code>) efficiently. The sorting order for <code>b</code> and <code>c</code> is broken after the range condition on <code>a</code>.</li><li>As a result, the database has to <strong>perform a full scan</strong> within the <code>a &gt;= 1</code> range to find rows that match <code>b = 1</code> and <code>c = 1</code>.</li></ol><h3><span id="case-2-using-indexb-c-a">Case 2: Using INDEX(b, c, a)</span></h3><p>Now let’s change the index to INDEX(b, c, a) and adjust the query accordingly:</p><div class="highlight"><pre class="code"><code><span class="hljs-attribute">SELECT</span> * FROM my_table WHERE b = <span class="hljs-number">1</span> AND c = <span class="hljs-number">1</span> AND a &gt;= <span class="hljs-number">1</span>;</code></pre></div><p>Here’s how MySQL processes it:</p><ol><li>First database will find rows where <code>b = 1</code>.</li><li>Within that range, it finds rows where <code>c = 1</code>.</li><li>Finally, it applies the range condition on <code>a</code>.</li></ol><p>Because <code>b</code> and <code>c</code> are exact mathces, the database could efficiently use the index for both columns before applying the range condition on <code>a</code>.</p><h2><span id="tips-how-to-choose-the-right-index-order">Tips: How to Choose the Right Index Order?</span></h2><ol><li><strong>Put equality conditions first</strong>: Columns that use <code>=</code> should come first in the index.</li><li><strong>Put range conditions last</strong>: Columns that use <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;</code>, etc., should be placed last in the index.</li><li><strong>Design indexes based on your most frequent queries</strong>.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#scenario-how-would-you-index-this-query&quot;&gt;Scenario: How Would You Index This Query?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#un</summary>
      
    
    
    
    <category term="Database" scheme="https://leungll.site/categories/Database/"/>
    
    
    <category term="index" scheme="https://leungll.site/tags/index/"/>
    
    <category term="range query" scheme="https://leungll.site/tags/range-query/"/>
    
  </entry>
  
  <entry>
    <title>Designing Data-Intensive Applications - Part I Foundations of Data Systems</title>
    <link href="https://leungll.site/2024/12/23/DDIA-Part-1/"/>
    <id>https://leungll.site/2024/12/23/DDIA-Part-1/</id>
    <published>2024-12-23T16:11:42.000Z</published>
    <updated>2025-04-01T05:03:42.677Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#chapter-1-reliable-scalable-and-maintainable-applications">CHAPTER 1 Reliable, Scalable, and Maintainable Applications</a><ul><li><a href="#thinking-about-data-systems">Thinking About Data Systems</a></li><li><a href="#reliability">Reliability</a><ul><li><a href="#human-errors">Human Errors</a></li></ul></li><li><a href="#scalability">Scalability</a><ul><li><a href="#describing-load">Describing Load</a></li><li><a href="#approaches-for-coping-with-load">Approaches for Coping with Load</a></li></ul></li><li><a href="#maintainability">Maintainability</a></li></ul></li><li><a href="#chapter-2-data-models-and-query-languages">CHAPTER 2 Data Models and Query Languages</a><ul><li><a href="#relational-model-versus-document-model">Relational Model Versus Document Model</a></li><li><a href="#query-languages-for-data">Query Languages for Data</a><ul><li><a href="#declarative-queries-on-web">Declarative Queries on Web</a></li><li><a href="#mapreduce-querying">MapReduce Querying</a></li></ul></li></ul></li><li><a href="#chapter-3-storage-and-retrieval">CHAPTER 3 Storage and Retrieval</a><ul><li><a href="#data-structures-that-power-your-database">Data Structures That Power Your Database</a><ul><li><a href="#hash-indexes">Hash Indexes</a></li><li><a href="#sstables-and-lsm-trees">SSTables and LSM-Trees</a></li><li><a href="#b-trees">B-Trees</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="chapter-1-reliable-scalable-and-maintainable-applications">CHAPTER 1 Reliable, Scalable, and Maintainable Applications</span></h1><h2><span id="thinking-about-data-systems">Thinking About Data Systems</span></h2><p>One possible architecture for a data system that combines several components.</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/DDIA-Part1-C1-01.png" alt="DDIA-Part1-C1-01"></p><p>Three concerns that are important in most software systems:</p><p><strong>Reliability</strong></p><ul><li>The system should continue to <strong>work correctly</strong> (performing the correct function at the desired level of performance) even in the face of adversity (hardware or software faults, and even human error).</li></ul><p><strong>Scalability</strong></p><ul><li>As the system grows (in data volume, traffic volume, or complexity), there should <strong>be reasonable ways of dealing with that growth</strong>.</li></ul><p><strong>Maintainbility</strong></p><ul><li>Over time, many different people will work on the system (engineering and operations, both maintaining current behavior and adapting the system to new use cases), and they should all be able to <strong>work on it productively</strong>.</li></ul><h2><span id="reliability">Reliability</span></h2><h3><span id="human-errors">Human Errors</span></h3><blockquote><p>One study of large internet services found that <strong>configuration errors by operators were the leading cause of outages</strong>, whereas hardware faults (servers or network) played a role in only 10–25% of outages.</p></blockquote><p>How do we make our systems reliable, in spite of unreliable humans?</p><ul><li><strong>Design systems</strong> in a way that <strong>minimizes opportunities for error</strong>. For example, well-designed abstractions, APIs, and admin interfaces.</li><li><strong>Decouple the places</strong> where people make the most mistakes from the places where they can cause failures. In particular, <strong>provide fully featured non-production sandbox environments</strong> where people can explore and experiment safely, using real data, without affecting real users.</li><li><strong>Test thoroughly</strong> at all levels, from unit tests to whole-system integration tests and manual tests. Automated testing is widely used.</li><li>Allow <strong>quick and easy recovery</strong> from human errors, to <strong>minimize the impact in the case of a failure</strong>. For example, <strong>make it fast to roll back configuration changes</strong>, <strong>roll out new code gradually</strong> (so that any unexpected bugs affect only a small subset of users), and provide tools to recompute data.</li><li>Set up <strong>detailed and clear monitoring</strong>, such as performance metrics and error rates.</li><li>Implement good management practices and training—a complex and important aspect.</li></ul><h2><span id="scalability">Scalability</span></h2><h3><span id="describing-load">Describing Load</span></h3><p>Let’s consider Twitter as an example.</p><p>Twitter’s scaling challenge is not primarily due to tweet volume, but due to <strong>fan-out</strong> - each user follows many people, and each user is followed by many people. There are broadly two ways of implementing these two operations:</p><ol><li><p>Posting a tweet simply <strong>inserts the new tweet</strong> into a global collection of tweets. When a user requests their home timeline, <strong>look up all the people they follow</strong>, find all the tweets for each of those users, and <strong>merge them (sorted by time)</strong>.</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/DDIA-Part1-C1-02.png" alt="DDIA-Part1-C1-02"></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/DDIA-Part1-C1-03.png" alt="DDIA-Part1-C1-03"></p></li><li><p><strong>Maintain a cache for each user’s home timeline</strong>—like a mailbox of tweets for each recipient user. When a user posts a tweet, <strong>look up all the people who follow that user, and insert the new tweet into each of their home timeline caches</strong>. The request to read the home timeline is then cheap, because its result has been computed ahead of time.</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/DDIA-Part1-C1-04.png" alt="DDIA-Part1-C1-04"></p></li></ol><p>The first version of Twitter used approach 1, but the systems struggled to keep up with the load of home timeline queries, so the company switched to approach 2. This works better because <strong>the average rate of published tweets is almost two orders of magnitude lower than the rate of home timeline reads</strong>, and so in this case it’s preferable to do more work at write time and less at read time.</p><p>In the example of Twitter, <strong>the distribution of followers per user (maybe weighted by how often those users tweet) is a key load parameter for discussing scalability</strong>, since it determines the fan-out load.</p><p>The final twist of the Twitter anecdote: now that approach 2 is robustly implemented, <strong>Twitter is moving to a hybrid of both approaches</strong>. <strong>Most users’ tweets continue to be fanned out to home timelines</strong> at the time when they are posted, but a small number of users with a very large number of followers (i.e., celebrities) are excepted from this fan-out. <strong>Tweets from any celebrities that a user may follow are fetched separately and merged with that user’s home timeline when it is read, like in approach 1</strong>.</p><h3><span id="approaches-for-coping-with-load">Approaches for Coping with Load</span></h3><p>People often talk of a dichotomy between <strong>scaling up</strong> (vertical scaling, moving to a more powerful machine) and <strong>scaling out</strong> (horizontal scaling, distributing the load across multiple smaller machines).</p><h2><span id="maintainability">Maintainability</span></h2><p>We will pay attention to three design principles for software systems:</p><ul><li><p>Operability</p><ul><li>Make it easy for <strong>operations teams</strong> to <strong>keep the system running smoothly</strong>.</li></ul></li><li><p>Simplicity</p><ul><li>Make it easy for <strong>new engineers</strong> to <strong>understand the system</strong>, by removing as much complexity as possible from the system.</li></ul></li><li><p>Evolvability</p><ul><li>Make it easy for <strong>engineers</strong> to <strong>make changes</strong> to the system in the future.</li></ul></li></ul><h1><span id="chapter-2-data-models-and-query-languages">CHAPTER 2 Data Models and Query Languages</span></h1><h2><span id="relational-model-versus-document-model">Relational Model Versus Document Model</span></h2><p>Document Model: The main arguments in favor of the document data model are <strong>schema flexibility</strong>, <strong>better performance due to locality</strong>, and that for some applications it is closer to the data structures used by the application.<br>Relational model: The relational model counters by providing <strong>better support for joins, and many-to-one and many-to-many relationships</strong>.</p><h2><span id="query-languages-for-data">Query Languages for Data</span></h2><p><strong>Declarative languages</strong>, like SQL, have a better chance of getting faster in parallel execution because they <strong>specify only the pattern of the results</strong>, not the algorithm that is used to determine the resules.</p><p><strong>Imperaive code</strong> is very hard to parallelize across multiple cores and multiple machines, because it <strong>specifies instructions that must be performed in a particular code</strong>.</p><h3><span id="declarative-queries-on-web">Declarative Queries on Web</span></h3><p>In a web browser, <strong>using declarative CSS styling</strong> is much better than manipulating styles imperatively in JavaScript. Similarly, in databases, <strong>declarative query languages like SQL turned out to be much better than imperative query APIs</strong>.</p><h3><span id="mapreduce-querying">MapReduce Querying</span></h3><p>MapReduce is a <strong>programming model</strong> for <strong>processing large amounts of data in bulk across many machines</strong>, popularized by Google. A limited form of MapReduce is supported by some NoSQL datastores, including MongoDB and CouchDB, as a mechanism for performing read-only queries across many documents.</p><p>MapReduce is neither a declarative query language nor a fully imperative query API, but somewhere in between: the logic of the query is expressed with snippets of code, which are called repeatedly by the processing framework. <strong>It is based on the map (also known as <u>collect</u>) and reduce (also known as <u>fold or inject</u>) functions</strong> that exist in many functional programming languages.</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/DDIA-Part1-C2-01.png" alt="DDIA-Part1-C2-01"></p><p>The <code>map</code> function would be called once for each document, resulting in emit(“1995-12”, 3) and emit (“1995-12”, 4). Subsequently, the reduce function would be called with reduce(“1995-12”, [3, 4]), returning 7.</p><p>MapReduce is a fairly <u>low-level programming model</u> for <u>distributed execution</u> on a cluster of machines. Higher-level query languages like SQL can be implemented as a pipeline of MapReduce operations.</p><p>A declarative query language offers more opportunities for a query optimizer to improve the performance of a query.</p><h1><span id="chapter-3-storage-and-retrieval">CHAPTER 3 Storage and Retrieval</span></h1><h2><span id="data-structures-that-power-your-database">Data Structures That Power Your Database</span></h2><h3><span id="hash-indexes">Hash Indexes</span></h3><p>A storage engine like <strong>Bitcask</strong> is well suited to situations where the value for each key is updated frequently.</p><p>Lots of detail goes into making this simple idea work in practice. Briefly, some of the issues that are important in a real implementations are:</p><p><strong>File format</strong></p><ul><li>CSV is not the best format for a log. It’s faster and simpler to use a <strong>binary format</strong> that first encodes the length of a string in bytes, followed by the raw string (without need for escaping).</li></ul><p><strong>Deleting records</strong></p><ul><li>If you want to delete a key and its associated, you have to <u>append a special deletion record to the data file</u> (sometimes called a <strong>tombstone</strong>). When log segments are merged, the tombstone tells the merging process to discard any previous values for the deleted key.</li></ul><p><strong>Crash recovery</strong></p><ul><li>Bitcask speeds up recovery by <u>storing a snapshot of each elements’s hash map on disk</u>, which can be loaded into memory more quickly.</li></ul><p><strong>Partially written records</strong></p><ul><li>The database may crash at any time, including halfway through appending a record to the log. Bitcask files include <strong>checksums</strong>, allowing such corrupted parts of the log to be detected and ignored.</li></ul><p><strong>Concurrenncy control</strong></p><ul><li>As writes are <u>appended to the log in a strictly sequential order</u>, a common implementation choice is to <u>have only one writer thread</u>. Data file segments are <strong>append-only</strong> and <strong>otherwise immutable</strong>, so they can be read concurrently by multiple threads.</li></ul><p>An append-only logs seems wasteful at first glance: why don’t you update the file in place, overwriting the old value with the new value? <strong>But an append-only design turns out to be good for several reasons</strong>:</p><ul><li><p><u>Appending and segment merging are sequential write operations</u>, which are generally much faster than random writes, expecially on magnetic spinning-disk hard drives.</p></li><li><p><u>Concurrenct and crash recovery are much simpler</u> if segment files are append-only or immutable. For example, you don’t have to worry about the case where a crash happened while a value was being overwritten, leaving you with a file containing part of the old and part of the new value spliced together.</p></li><li><p>Merging old segments <u>avoids the problem of data files getting fragmented</u> over time.</p></li></ul><p>However, <strong>the hash table index also has limitations</strong>:</p><ul><li><p><u>The hash table must fit in memory</u>. It is difficult to make an on-dish hash map perform well. It requires a lot of random access I/O, it is expensive to grow when it becomes full, and hash collisions require fiddly logic.</p></li><li><p><u>Range queries are not efficient</u>. For example, you cannot easily scan over all keys between kitty00000 and kitty99999 - you have to look up each key individually in the hash maps.</p></li></ul><h3><span id="sstables-and-lsm-trees">SSTables and LSM-Trees</span></h3><p>SSTbale: Sorted String Table</p><p><strong>Constructing and maintaining SSTables</strong><br>We can now make our storage engine work as follows:</p><ul><li><p>When a write comes in, <u>add it to an in-memory balanced tree</u> data structure (for example, a red-black tree). This in-memory tree is sometimes called a memtable.</p></li><li><p>When the memtable gets bigger than some threshold, <u>write it out to disk as an SSTable file</u>. This can be done efficiently because the tree already maintains the key-value pairs sorted by key. The new SSTable file becomes the most recend segment of the databse. While the SSTable is being written out to disk, writes can continue to a new memtable instance.</p></li><li><p>In order to serve a read request, first try to <u>find the key in the memtable</u>, then <u>in the most recent segment of the databse</u>, then <u>in the next-older segment</u>, etc.</p></li><li><p>From time to time, <u>run a merging and compaction process in the background</u> to combine segment files and to discard overwritten or deleted values.</p></li></ul><p>This scheme works very well. <strong>It only suffers from one problem</strong>: if the databse crashed, the most recent writes (which are in the memtable but not yet written out to disk) are lost.</p><p><strong>In order to avoid that problem</strong>, we can <u>keep a separate log on disk to which every write is immediately appended</u>. Every time the memtable is written out to an SSTable, the corresponding log can be discarded.</p><p><strong>Making an LSM-tree out of SSTables</strong><br>LSM-tree: Log-Structured Merge-Tree</p><p>Storage engines that are based on this principle of <u>merging and compacting sorted files</u> are often called <strong>LSM storage engines</strong>.</p><p><strong>Lucene</strong>, an indexing engine for full-text search used by Elasticsearch and Solr, uses a similar method for storing its term dictionary. A full-text index is much more complex than a key-value index <u>but is based on a similar idea: given a word in a search query, find all the documents (web pages, product descriptions, etc.) that mention the word.</u> This is implemented with a key-value structure where the <u>key is a word (a term)</u> and the <u>value is the list of IDs of all the documents that contain the word (the postings list).</u> In Lucene, this mapping from term to postings list is <u>kept in SSTable-like sorted files</u>, which are merged in the background as needed.</p><p><strong>Performance optimizations</strong><br>The LSM-tree algorithm can be slow when looking up keys that <u>do not exist in the database</u>: you have to check the <u>memtable</u>, then the <u>segments all the way back to the oldest</u> (possibly having to <u>read from disk</u> for each one) before you can be sure that the key does not exist. In order ro optimize this kind of access, storage engines often use additional <strong>Bloom filters</strong>. (A Bloom filter is a <strong>memory-efficient data structure</strong> for approximating the contents of a set. It can <u>tell you if a key does not appear in the database</u>, and thus saves many unnecessary disk reads for nonexistent keys.)</p><h3><span id="b-trees">B-Trees</span></h3><p>Like SSTable, B-trees keep key-value pairs sorted by key, which allows efficient key-value lookups and range queries. But that’s where the similarity ends: B-trees have a very different design philosophy.</p><p>The <strong>log-structured indexes</strong> we saw earlier <u>break the database down into variable-size segments</u>, typically several megabytes or more in size, and always <u>write a segment sequentially</u>. By contrast, <strong>B-trees</strong> <u>break the database down into fixed-size blocks or pages</u>, traditionally 4 KB in size (sometimes bigger), and read or write one page at a time.</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/DDIA-Part1-C3-01.png" alt="DDIA-Part1-C3-01"></p><p>One page is designated as the root of the B-tree; whenever you want to look up a key in the index, you start here. <u>The page contains several keys and references to child pages</u>. Each child is responsible <u>for a continuous range of keys</u>, and the <u>keys between the references indicate where the boundaries between those ranges lie</u>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#chapter-1-reliable-scalable-and-maintainable-applications&quot;&gt;CHAPTER 1 Reliable, Scalable, and Maintainable Ap</summary>
      
    
    
    
    <category term="System Design" scheme="https://leungll.site/categories/System-Design/"/>
    
    
    <category term="System Design" scheme="https://leungll.site/tags/System-Design/"/>
    
    <category term="Distributed System" scheme="https://leungll.site/tags/Distributed-System/"/>
    
    <category term="Data System" scheme="https://leungll.site/tags/Data-System/"/>
    
  </entry>
  
  <entry>
    <title>快速幂 &amp;&amp; 快速乘原理讲解（模板）</title>
    <link href="https://leungll.site/2021/05/24/ksm-permalink/"/>
    <id>https://leungll.site/2021/05/24/ksm-permalink/</id>
    <published>2021-05-24T13:49:46.000Z</published>
    <updated>2025-01-05T07:21:22.012Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">1 问题描述</a></li><li><a href="#2-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90">2 原因分析</a></li><li><a href="#3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">3 解决方法</a></li><li><a href="#4-%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%B2%E8%A7%A3">4 快速幂讲解</a></li><li><a href="#5-%E5%BF%AB%E9%80%9F%E4%B9%98%E8%AE%B2%E8%A7%A3">5 快速乘讲解</a></li><li><a href="#6-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">6 完整代码</a></li><li><a href="#7-references">7 References</a></li></ul><!-- tocstop --><h2><span id="1-问题描述">1 问题描述</span></h2><blockquote><p>我们发现，在 <span class="markdown-them-math-inline">$int$</span> 型下使用 <span class="markdown-them-math-inline">$pow$</span> 函数求 <span class="markdown-them-math-inline">$5^{3}$</span>，结果为 <span class="markdown-them-math-inline">$124$</span> 。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/ksm-1.png" alt="ksm-1"></p><h2><span id="2-原因分析">2 原因分析</span></h2><blockquote><p><span class="markdown-them-math-inline">$pow$</span> 函数的返回值为 <code>double</code> 型 ，因浮点数长度问题，存在截断误差。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/ksm-2.png" alt="ksm-2"></p><h2><span id="3-解决方法">3 解决方法</span></h2><blockquote><p>将变量定义为 <code>double</code> 型</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/ksm-3.png" alt="ksm-3"></p><p><strong>有没有更快求幂的方法？</strong></p><h2><span id="4-快速幂讲解">4 快速幂讲解</span></h2><blockquote><p>假设我们要求 <span class="markdown-them-math-inline">$a^{b}$</span> ，按照朴素算法就是把 a 连乘 b 次，这样一来时间复杂度是 <span class="markdown-them-math-inline">$O(b)$</span> ，即是 <span class="markdown-them-math-inline">$O(n)$</span> 级别。但快速幂能做到 <span class="markdown-them-math-inline">$O(logn)$</span> 的复杂度。</p></blockquote><p>快速幂：<br><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/ksm-4.png" alt="ksm-4"></p><p>对于二进制的位运算，我们需要用到 <code>&amp;</code> 与 <code>&gt;&gt;</code> 运算符，详见 <a href="https://blog.csdn.net/liangllhahaha/article/details/79382094">位运算符的应用</a></p><p><strong>先上实现快速幂运算的具体代码：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ksm</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>, base = a;    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>) &#123;    ans *= base;&#125;base *= base;b &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>其中 <code>b &amp; 1</code> 指取 b 的二进制数的最末位，如 <code>11</code> 的二进制数为 <code>1011</code> ，第一次循环，取的是最右边的 <code>1</code> ，以此类推。</p><p>而 <code>b &gt;&gt;= 1</code> 等效于 <code>b = b &gt;&gt; 1</code>，即右移 <code>1</code> 位，删去最低位。</p><p><strong>以 <span class="markdown-them-math-inline">$a ^ {11}$</span> 为例：</strong></p><p><code>b</code> 的二进制数为 <code>1011</code>，二进制从右向左算，但乘出来的顺序是 <span class="markdown-them-math-inline">$a^{2^{0}} * a^{2^{1}} * a^{2^{3}}$</span> ，是从左向右的。我们不断的让 <span class="markdown-them-math-inline">$base\,*=\,base$</span> 目的是累乘，以便随时对 <code>ans</code> 做出贡献。</p><blockquote><p>要理解 <span class="markdown-them-math-inline">$base*=base$</span> 这一步：因为 <span class="markdown-them-math-inline">$base\,*\,base == base^{2}$</span>，下一步再乘，就是 <span class="markdown-them-math-inline">$base^{2} * base^{2} == base^{4}$</span>，然后同理 <span class="markdown-them-math-inline">$base^{4} * base^{4} == base^{8}$</span>，由此可以做到 <span class="markdown-them-math-inline">$base→ base^{2} → base^{4} → base^{8} → base^{16} → base^{32}$</span> … 指数正好是 <span class="markdown-them-math-inline">$2^{i}$</span>。再看上面的例子，<span class="markdown-them-math-inline">$a^{11} = a^{1}\,*\,a^{2}\,*\,a^{8}$</span> ，这三项就可以完美解决了，快速幂就是这样。</p></blockquote><p>如还有不明白的地方，建议手动模拟代码的运行过程。</p><h2><span id="5-快速乘讲解">5 快速乘讲解</span></h2><blockquote><p>我们知道，在计算机中做加法运算会比乘法快得多（参考模电中的加法器），做乘法运算往往会溢出，即使用 long long 类型也拯救不了。因此需要寻找一种能高效完成乘法运算且不会溢出的算法，这就是快速乘算法。</p></blockquote><p>快速乘与快速幂原理相似，也是将运算转换为二进制处理.</p><p>以 <span class="markdown-them-math-inline">$a * 11$</span> 为例:  <code>11</code> 的二进制数为 <code>1011</code>，则有 <span class="markdown-them-math-inline">$a * 11 = a * 2^{0}\,+\,a * 2^{1}\,+\,a * 2^{3}$</span></p><p>就是把快速幂中的 <code>*</code> 号改为 <code>＋</code> 号</p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ksc</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>) &#123;    ans += a;&#125;a += a;b &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>此版本的复杂度和快速幂一样，也是 <span class="markdown-them-math-inline">$O(logn)$</span> 。如果需要特别卡常数，可以去了解 <span class="markdown-them-math-inline">$O(1)$</span> 版本的快速乘。</p><h2><span id="6-完整代码">6 完整代码</span></h2><blockquote><p>为了防止溢出，一般快速幂和快速乘的算法会在 <span class="markdown-them-math-inline">$mod$</span> 下运用，下面给出取模运算代码。</p></blockquote><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> ll mod = <span class="hljs-number">1e7</span>; <span class="hljs-comment">//a ^ b</span><span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll a, ll b, ll mod)</span> </span>&#123;    ll ans = <span class="hljs-number">1</span>, base = a;    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>) &#123;    ans = (ans * base) % mod;&#125;base = (base * base) % mod;b &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125; <span class="hljs-comment">//a * b</span><span class="hljs-function">ll <span class="hljs-title">ksc</span><span class="hljs-params">(ll a, ll b, ll mod)</span> </span>&#123;    ll ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span>) &#123;    ans = (ans + a) % mod;&#125;a = (a + a) % mod;b &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;5 ^ 3 = &quot;</span> &lt;&lt; <span class="hljs-built_in">ksm</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, mod) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;345352 * 11 = &quot;</span> &lt;&lt; <span class="hljs-built_in">ksc</span>(<span class="hljs-number">345352</span>, <span class="hljs-number">11</span>, mod) &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>运算结果：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/ksm-5.png" alt="ksm-5"></p><h2><span id="7-references">7 References</span></h2><ul><li><a href="https://www.cnblogs.com/CXCXCXC/p/4641812.html">https://www.cnblogs.com/CXCXCXC/p/4641812.html</a></li></ul><p>以上，有问题欢迎指正！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0&quot;&gt;1 问题描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="快速幂" scheme="https://leungll.site/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="快速乘" scheme="https://leungll.site/tags/%E5%BF%AB%E9%80%9F%E4%B9%98/"/>
    
  </entry>
  
  <entry>
    <title>Win10 系统 MySQL &amp;&amp; Navicat Premium12 安装教程</title>
    <link href="https://leungll.site/2021/01/25/mysql-navicat-install/"/>
    <id>https://leungll.site/2021/01/25/mysql-navicat-install/</id>
    <published>2021-01-26T03:28:27.000Z</published>
    <updated>2025-01-05T07:21:26.142Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-mysql%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85">1 MySQL的下载与安装</a><ul><li><a href="#11-%E8%BF%9B%E5%85%A5mysql%E5%AE%98%E7%BD%91">1.1 进入MySQL官网</a></li><li><a href="#12-mysql%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE">1.2 MySQL安装及环境变量配置</a></li><li><a href="#13-%E5%90%AF%E5%8A%A8mysql%E6%9C%8D%E5%8A%A1">1.3 启动MySQL服务</a></li></ul></li><li><a href="#2-navicat%E5%AE%89%E8%A3%85">2 Navicat安装</a><ul><li><a href="#21-%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD">2.1 安装包下载</a></li><li><a href="#22-navicat%E5%AE%89%E8%A3%85">2.2 Navicat安装</a></li><li><a href="#23-%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%8E%8B">2.3 文件夹解压</a></li></ul></li><li><a href="#3-navicat%E8%BF%9E%E6%8E%A5mysql">3 Navicat连接MySQL</a><ul><li><a href="#31-%E8%BF%9E%E6%8E%A5localhost">3.1 连接localhost</a></li><li><a href="#32-%E4%BF%AE%E6%94%B9mysql%E5%AF%86%E7%A0%81">3.2 修改MySQL密码</a></li></ul></li></ul><!-- tocstop --><blockquote><p>注：本文以 Win 10 系统 + 64 位为例</p></blockquote><h2><span id="1-mysql的下载与安装">1 MySQL的下载与安装</span></h2><h3><span id="11-进入mysql官网">1.1 进入MySQL官网</span></h3><p>官网链接：<a href="https://dev.mysql.com/downloads/mysql">https://dev.mysql.com/downloads/mysql</a></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-1.png" alt="mysql-navicat-install-1"></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-2.png" alt="mysql-navicat-install-2"></p><h3><span id="12-mysql安装及环境变量配置">1.2 MySQL安装及环境变量配置</span></h3><p><strong>1. 从官网下载完毕后，并解压 zip 安装包，安装包结构如图所示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-3.png" alt="mysql-navicat-install-3"></p><p><strong>2. 配置环境变量：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-4.png" alt="mysql-navicat-install-4"></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-5.png" alt="mysql-navicat-install-5"></p><p><strong>3. 配置初始化的 my.ini 文件</strong></p><p>发现解压后的目录并没有 <code>my.ini</code> 文件，没关系可以自行创建。在安装包的<strong>根目录</strong>下添加 <code>my.ini</code>（新建文本文件，将文件类型改为 <code>.ini</code> ），写入基本配置：</p><div class="highlight"><pre class="code"><code><span class="hljs-section">[mysqld]</span><span class="hljs-comment"># 设置3306端口</span><span class="hljs-attr">port</span>=<span class="hljs-number">3306</span><span class="hljs-comment"># 设置mysql的安装目录</span><span class="hljs-attr">basedir</span>=D:\\Program Files\\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">15</span>-winx64  <span class="hljs-comment"># 设置mysql数据库的数据的存放目录</span><span class="hljs-attr">datadir</span>=D:\\Program Files\\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">15</span>-winx64\\Data  <span class="hljs-comment"># 允许最大连接数</span><span class="hljs-attr">max_connections</span>=<span class="hljs-number">200</span><span class="hljs-comment"># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span><span class="hljs-attr">max_connect_errors</span>=<span class="hljs-number">10</span><span class="hljs-comment"># 服务端使用的字符集默认为UTF8</span><span class="hljs-attr">character-set-server</span>=utf8<span class="hljs-comment"># 创建新表时将使用的默认存储引擎</span><span class="hljs-attr">default-storage-engine</span>=INNODB<span class="hljs-comment"># 默认使用“mysql_native_password”插件认证</span><span class="hljs-attr">default_authentication_plugin</span>=mysql_native_password<span class="hljs-section">[mysql]</span><span class="hljs-comment"># 设置mysql客户端默认字符集</span><span class="hljs-attr">default-character-set</span>=utf8<span class="hljs-section">[client]</span><span class="hljs-comment"># 设置mysql客户端连接服务端时默认使用的端口</span><span class="hljs-attr">port</span>=<span class="hljs-number">3306</span><span class="hljs-attr">default-character-set</span>=utf8</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-6.png" alt="mysql-navicat-install-6"></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-7.png" alt="mysql-navicat-install-7"></p><h3><span id="13-启动mysql服务">1.3 启动MySQL服务</span></h3><p><strong>1. 以管理员身份运行 cmd（否则在安装时会报错，会导致安装失败的情况）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-8.png" alt="mysql-navicat-install-8"></p><p><strong>2. 命令行进入 mysql 安装包的 bin 文件：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-attribute">cd</span>/d D:\Program Files\mysql-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>-winx<span class="hljs-number">64</span>\bin</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-9.png" alt="mysql-navicat-install-9"></p><p><strong>3. 初始化数据库：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-comment">mysqld</span> --<span class="hljs-comment">initialize</span> --<span class="hljs-comment">console</span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-10.png" alt="mysql-navicat-install-10"></p><p>执行完成后，会打印 <strong>root 用户的初始默认密码</strong>（即 mysql 密码），例如我的：</p><p><strong>注意</strong>：一定要记住 mysql 的初始密码，以便之后 navicat 连接 mysql 输入密码（及修改密码）用。</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-11.png" alt="mysql-navicat-install-11"></p><p><strong>3. 安装服务：</strong></p><div class="highlight"><pre class="code"><code>mysqld <span class="hljs-comment">--install [服务名]</span></code></pre></div><p>后面的服务名可以不写，默认的名字为 mysql 。当然，如果你的电脑上需要安装多个 MySQL 服务，就可以用不同的名字区分，比如 mysql5 和 mysql8 。</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-12.png" alt="mysql-navicat-install-12"></p><p><strong>4. 启动服务：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mysql</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-13.png" alt="mysql-navicat-install-13"></p><h2><span id="2-navicat安装">2 Navicat安装</span></h2><h3><span id="21-安装包下载">2.1 安装包下载</span></h3><p><strong>链接</strong>：<a href="https://pan.baidu.com/s/1t8QxfnEhrcvYZPYOSLbw-A">https://pan.baidu.com/s/1t8QxfnEhrcvYZPYOSLbw-A</a> 提取码：<code>h18n</code> （链接失效可联系我）</p><h3><span id="22-navicat安装">2.2 Navicat安装</span></h3><p><strong>1. 解压安装包后，点击 exe 文件安装：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-14.png" alt="mysql-navicat-install-14"></p><p><strong>2. 选择安装路径后，一路 next 即可：</strong></p><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-15.png" alt="mysql-navicat-install-15"></th><th><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-16.png" alt="mysql-navicat-install-16"></th></tr></thead></table><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-17.png" alt="mysql-navicat-install-17"></th><th><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-18.png" alt="mysql-navicat-install-18"></th></tr></thead></table><h3><span id="23-文件夹解压">2.3 文件夹解压</span></h3><p><strong>1. 解压文件：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-19.png" alt="mysql-navicat-install-19"></p><p><strong>2. 将该“简体中文 64 位”目录下的两个文件拷贝至 navicat 安装目录的根目录：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-20.png" alt="mysql-navicat-install-20"></p><p><strong>3. 打开 navicat ，可以看到已经安装成功</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-21.png" alt="mysql-navicat-install-21"></p><p><strong>注：采用此安装方式，不建议升级更新 Navicat Premium</strong></p><h2><span id="3-navicat连接mysql">3 Navicat连接MySQL</span></h2><h3><span id="31-连接localhost">3.1 连接localhost</span></h3><p><strong>1. 建立连接：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-22.png" alt="mysql-navicat-install-22"></p><p><strong>2. 输入密码（初始密码）：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-23.png" alt="mysql-navicat-install-23"></p><p><strong>3. 连接成功：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-24.png" alt="mysql-navicat-install-24"></p><h3><span id="32-修改mysql密码">3.2 修改MySQL密码</span></h3><p><strong>1. 点击“用户”，选择账号 “root@localhost”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-25.png" alt="mysql-navicat-install-25"></p><p><strong>2. 修改密码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/mysql-navicat-install-26.png" alt="mysql-navicat-install-26"></p><p>保存即可</p><p>OK，至此 MySQL 与 Navicat Premium12 均已安装完毕，欢迎留言讨论！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-mysql%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85&quot;&gt;1 MySQL的下载与安装&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-%E8%B</summary>
      
    
    
    
    <category term="后端开发" scheme="https://leungll.site/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="后端开发" scheme="https://leungll.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Configuration" scheme="https://leungll.site/tags/Configuration/"/>
    
    <category term="MySQL" scheme="https://leungll.site/tags/MySQL/"/>
    
    <category term="Navicat Premium 12" scheme="https://leungll.site/tags/Navicat-Premium-12/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2017初赛 C/C++大学A组】迷宫（dfs模板）</title>
    <link href="https://leungll.site/2020/10/12/oj-1317/"/>
    <id>https://leungll.site/2020/10/12/oj-1317/</id>
    <published>2020-10-12T11:38:14.000Z</published>
    <updated>2024-05-03T13:37:10.439Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接</strong>：<a href="http://oj.ecustacm.cn/problem.php?id=1317">http://oj.ecustacm.cn/problem.php?id=1317</a></p><h2><span id="1-题目">1 题目</span></h2><h3><span id="题目描述">题目描述</span></h3><blockquote><p>X 星球的一处迷宫游乐场建在某个小山坡上。它是由 10x10 相互连通的小房间组成的。房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：L 表示走到左边的房间，R 表示走到右边的房间，U 表示走到上坡方向的房间，D 表示走到下坡方向的房间。X 星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！开始的时候，直升机把 100 名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。</p><p>迷宫地图如下：</p><div class="highlight"><pre class="code"><code><span class="hljs-attribute">UDDLUULRULUURLLLRRRURRUURLDLRDRUDDDDUUUUURUDLLRRUUDURLRLDLRLULLURLLRDURDLULLRDDDUUDDUDUDLLULRDLUURRR</span></code></pre></div><p>请你计算一下，最后，有多少玩家会走出迷宫? 而不是在里边兜圈子。</p></blockquote><h3><span id="输出格式">输出格式</span></h3><blockquote><p>输出一个整数表示答案</p></blockquote><h2><span id="2-题解">2 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">char</span> c[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">9</span> || j &gt; <span class="hljs-number">9</span>)&#123;        ans++;        <span class="hljs-keyword">return</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span>(vis[i][j])&#123;            <span class="hljs-keyword">return</span>;        &#125;        vis[i][j] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-string">&#x27;U&#x27;</span>)&#123;            <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-string">&#x27;D&#x27;</span>)&#123;            <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, j);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;            <span class="hljs-built_in">dfs</span>(i, j - <span class="hljs-number">1</span>);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-string">&#x27;R&#x27;</span>)&#123;            <span class="hljs-built_in">dfs</span>(i, j + <span class="hljs-number">1</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">10</span>;j++)&#123;            cin &gt;&gt; c[i][j];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">10</span>;j++)&#123;            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));            <span class="hljs-built_in">dfs</span>(i, j);        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接&lt;/strong&gt;：&lt;a href=&quot;http://oj.ecustacm.cn/problem.php?id=1317&quot;&gt;http://oj.ecustacm.cn/problem.php?id=1317&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="蓝桥杯" scheme="https://leungll.site/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="bfs" scheme="https://leungll.site/tags/bfs/"/>
    
    <category term="迷宫" scheme="https://leungll.site/tags/%E8%BF%B7%E5%AE%AB/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 2019初赛 C/C++大学A组】迷宫（bfs模板）</title>
    <link href="https://leungll.site/2020/10/12/oj-1455/"/>
    <id>https://leungll.site/2020/10/12/oj-1455/</id>
    <published>2020-10-12T11:29:14.000Z</published>
    <updated>2024-05-03T13:41:02.011Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接</strong>：<a href="http://oj.ecustacm.cn/problem.php?id=1455">http://oj.ecustacm.cn/problem.php?id=1455</a></p><h2><span id="1-题目">1 题目</span></h2><h3><span id="题目描述">题目描述</span></h3><blockquote><p>下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。</p><div class="highlight"><pre class="code"><code>010000000100001001110000</code></pre></div><p>迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。<br>对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。<br>对于下面这个更复杂的迷宫（ 30 行 50 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为案。<br>请注意在字典序中 <span class="markdown-them-math-inline">$D&lt;L&lt;R&lt;U$</span>。</p></blockquote><h3><span id="输入格式">输入格式</span></h3><blockquote><p>见文件：<a href="http://oj.ecustacm.cn/upload/file/20200122/20200122134020_61830.txt">http://oj.ecustacm.cn/upload/file/20200122/20200122134020_61830.txt</a></p></blockquote><h2><span id="2-题解">2 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">60</span>;<span class="hljs-keyword">char</span> mp[maxn][maxn];<span class="hljs-keyword">int</span> vis[maxn][maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-keyword">char</span> dirc[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>&#125;;<span class="hljs-keyword">int</span> n, m;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>    <span class="hljs-keyword">int</span> x, y, step;    string s;    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> xx, <span class="hljs-keyword">int</span> yy, <span class="hljs-keyword">int</span> sstep, string ss)&#123;        x = xx;        y = yy;        step = sstep;        s = ss;    &#125;&#125;;queue&lt;node&gt; q;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m || vis[x][y] == <span class="hljs-number">1</span> || mp[x][y] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(x, y, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>));    vis[x][y] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;        node now = q.<span class="hljs-built_in">front</span>();        <span class="hljs-keyword">if</span>(now.x == n - <span class="hljs-number">1</span> &amp;&amp; now.y == m - <span class="hljs-number">1</span>)&#123;            cout &lt;&lt; now.s &lt;&lt; endl;            cout &lt;&lt; now.step &lt;&lt; endl;            <span class="hljs-keyword">break</span>;        &#125;        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++)&#123;            <span class="hljs-keyword">int</span> nx = now.x + dir[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> ny = now.y + dir[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(nx, ny))&#123;                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(nx, ny, now.step + <span class="hljs-number">1</span>, now.s + dirc[i]));                vis[nx][ny] = <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">//ONLINE_JUDGE</span></span>    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        cin &gt;&gt; mp[i];    &#125;    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接&lt;/strong&gt;：&lt;a href=&quot;http://oj.ecustacm.cn/problem.php?id=1455&quot;&gt;http://oj.ecustacm.cn/problem.php?id=1455&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="蓝桥杯" scheme="https://leungll.site/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="bfs" scheme="https://leungll.site/tags/bfs/"/>
    
    <category term="迷宫" scheme="https://leungll.site/tags/%E8%BF%B7%E5%AE%AB/"/>
    
  </entry>
  
  <entry>
    <title>编程笔记</title>
    <link href="https://leungll.site/2020/08/04/algorithm-notes/"/>
    <id>https://leungll.site/2020/08/04/algorithm-notes/</id>
    <published>2020-08-04T15:16:48.000Z</published>
    <updated>2025-01-05T07:08:00.503Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86">1 输入输出处理</a></li><li><a href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8">2 数据类型应用</a></li><li><a href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2">3 字符串</a></li><li><a href="#4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">4 排序算法</a></li><li><a href="#5-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">5 进制转换</a></li><li><a href="#6-%E5%85%B6%E4%BB%96">6 其他</a></li></ul><!-- tocstop --><h3><span id="1-输入输出处理">1 输入输出处理</span></h3><ul><li><p><span class="markdown-them-math-inline">$scanf$</span> 函数</p><ul><li>字符数组使用 <code>%s</code>读入时，以 <strong>空格</strong> 跟 <strong>换行</strong> 为读入结束标志</li><li><code>%c</code> 格式可读入 <strong>空格</strong> 跟 <strong>换行</strong></li></ul></li><li><p><span class="markdown-them-math-inline">$getchar$</span> 用来输入单个字符，可 <strong>识别换行符</strong>；<span class="markdown-them-math-inline">$putchar$</span> 用来输出单个字符</p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">char</span> c;<span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">putchar</span>(c);</code></pre></div></li><li><p>不要同时在一个程序中使用 <span class="markdown-them-math-inline">$cout$</span> 和 <span class="markdown-them-math-inline">$printf$</span></p></li></ul><h3><span id="2-数据类型应用">2 数据类型应用</span></h3><ul><li><p>四种基本数据类型</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/algorithm-notes-01.jpg" alt="algorithm-notes-01"></p></li><li><p>对于浮点型，不要使用 <span class="markdown-them-math-inline">$float$</span></p></li></ul><h3><span id="3-字符串">3 字符串</span></h3><ul><li><p><span class="markdown-them-math-inline">$sscanf$</span> 与 <span class="markdown-them-math-inline">$sprintf$</span></p><ul><li>假设定义一个 <span class="markdown-them-math-inline">$char$</span>  数组 <span class="markdown-them-math-inline">$str[100]$</span><ul><li><span class="markdown-them-math-inline">$sscanf$</span>：<code>sscanf(str, &quot;%d&quot;, &amp;n);</code></li><li><span class="markdown-them-math-inline">$sprintf$</span>：<code>sprintf(str, &quot;%d&quot;, n;</code></li></ul></li></ul></li><li><p><span class="markdown-them-math-inline">$strcmp$</span> 函数的返回值不一定是 <span class="markdown-them-math-inline">$-1$</span> 或 <span class="markdown-them-math-inline">$+1$</span>（与编译器有关）</p><ul><li>类似 <code>return strcmp(a.name, b.name) == -1</code>（字典序小的排在前面）的写法是错误的</li><li>正确写法：<code>return strcmp(a.name, b.name) &lt; 0</code></li></ul></li></ul><h3><span id="4-排序算法">4 排序算法</span></h3><ul><li><p>选择排序</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/algorithm-notes-02.jpg" alt="algorithm-notes-02"></p></li><li><p>插入排序</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/algorithm-notes-03.jpg" alt="algorithm-notes-03"></p></li></ul><h3><span id="5-进制转换">5 进制转换</span></h3><ul><li><p><span class="markdown-them-math-inline">$P$</span> 进制数 <span class="markdown-them-math-inline">$x$</span> 转换为十进制数 <span class="markdown-them-math-inline">$y$</span></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/algorithm-notes-04.jpg" alt="algorithm-notes-04"></p></li><li><p>十进制数 <span class="markdown-them-math-inline">$y$</span> 转换为 <span class="markdown-them-math-inline">$Q$</span> 进制数 <span class="markdown-them-math-inline">$z$</span> （除基取余法）</p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">int</span> z[<span class="hljs-number">40</span>], num = <span class="hljs-number">0</span>;    <span class="hljs-comment">//数组z存放Q进制数y的每一位，num为位数</span><span class="hljs-keyword">do</span>&#123;z[num++] = y % Q;  <span class="hljs-comment">//除基取余</span>y /= Q;&#125;<span class="hljs-keyword">while</span>(y != <span class="hljs-number">0</span>);        <span class="hljs-comment">//当商不为0时进行循环</span></code></pre></div><p><span class="markdown-them-math-inline">$z$</span> 数组从高位 <span class="markdown-them-math-inline">$z[num - 1]$</span> 到低位 <span class="markdown-them-math-inline">$z[0]$</span> 即为 <span class="markdown-them-math-inline">$Q$</span> 进制 <span class="markdown-them-math-inline">$z$</span></p></li></ul><h3><span id="6-其他">6 其他</span></h3><ul><li><p>闰年表示：<code>(year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400  == 0)</code></p></li><li><p><span class="markdown-them-math-inline">$ASCII$</span>：小写字母的值比大写字母大 <span class="markdown-them-math-inline">$32$</span></p></li><li><p>注释技巧：</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOCAL</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> LOCAL</span>    cout &lt;&lt; endl;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></div></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86&quot;&gt;1 输入输出处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E6%95%B0%E6%8D%</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法笔记" scheme="https://leungll.site/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【PAT甲级】1022 Digital Library（map映射，scanf、getline、getchar用法）</title>
    <link href="https://leungll.site/2020/07/22/pat-1022/"/>
    <id>https://leungll.site/2020/07/22/pat-1022/</id>
    <published>2020-07-23T03:46:24.000Z</published>
    <updated>2024-04-29T11:53:38.811Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805480801550336">1022 Digital Library (30分)</a></strong></p><h2><span id="1-题目描述">1 题目描述</span></h2><blockquote><p>A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s.</p></blockquote><h3><span id="input-specification">Input Specification</span></h3><blockquote><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 10​4​​) which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines:</p><ul><li>Line #1: the 7-digit ID number;</li><li>Line #2: the book title – a string of no more than 80 characters;</li><li>Line #3: the author – a string of no more than 80 characters;</li><li>Line #4: the key words – each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;</li><li>Line #5: the publisher – a string of no more than 80 characters;</li><li>Line #6: the published year – a 4-digit number which is in the range [1000, 3000].</li></ul><p>It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.<br>After the book information, there is a line containing a positive integer M (≤ 1000) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below:</p><ul><li>1: a book title</li><li>2: name of an author</li><li>3: a key word</li><li>4: name of a publisher</li><li>5: a 4-digit number representing the year</li></ul></blockquote><h3><span id="output-specification">Output Specification</span></h3><blockquote><p>For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print <code>Not Found</code> instead.</p></blockquote><h3><span id="sample-input">Sample Input</span></h3><div class="highlight"><pre class="code"><code>31111111The Testing BookYue Chen<span class="hljs-keyword">test </span>code debug sort keywordsZUCS Print20113333333Another Testing BookYue Chen<span class="hljs-keyword">test </span>code sort keywordsZUCS Print220122222222The Testing BookCYLLkeywords debug bookZUCS Print2201161: The Testing Book2: Yue Chen3: keywords4: ZUCS Print5: 20113: blablabla</code></pre></div><h3><span id="sample-output">Sample Output</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-number">1</span>: The Testing Book<span class="hljs-number">1111111</span><span class="hljs-number">2222222</span><span class="hljs-number">2</span>: Yue Chen<span class="hljs-number">1111111</span><span class="hljs-number">3333333</span><span class="hljs-number">3</span>: keywords<span class="hljs-number">1111111</span><span class="hljs-number">2222222</span><span class="hljs-number">3333333</span><span class="hljs-number">4</span>: ZUCS Print<span class="hljs-number">1111111</span><span class="hljs-number">5</span>: <span class="hljs-number">2011</span><span class="hljs-number">1111111</span><span class="hljs-number">2222222</span><span class="hljs-number">3</span>: blablablaNot Found</code></pre></div><h2><span id="2-解题思路">2 解题思路</span></h2><ul><li><strong>题目大意</strong>：模拟数字图书馆的查询功能。会给出 <span class="markdown-them-math-inline">$n$</span> 本书的信息，以及 <span class="markdown-them-math-inline">$m$</span> 个需要查询的命令，数字标号对应相应的命令，数字编号后面的字符串是查询的搜索词，要求输出这行命令以及输出满足条件的书的 <code>id</code> ，如果一个都没有找到，输出 <code>Not Found</code>。</li><li><strong>解题技巧</strong>：<ul><li>使用<code>map&lt; string, set&lt;int&gt; &gt;</code>对图书信息进行存储，<code>string</code>存储关键字信息，<code>set&lt;int&gt;</code>存储图书 <span class="markdown-them-math-inline">$id$</span></li><li>使用<code>getline(cin, ttitle)</code>快速处理多行输入数据</li><li>对于关键词 <span class="markdown-them-math-inline">$keywords$</span> ：未知关键词个数，可使用<code>while(cin &gt;&gt; tkry)</code>进行判断，当<code>getchar()为'\n' </code>时，则跳出循环</li><li>对于输入数据<code>1: The Testing Book</code>：可使用<code>scanf(&quot;%d: &quot;, &amp;num)</code>，对多余信息<code>:</code>进行过滤处理，以提取有效信息</li><li>对于输入 <span class="markdown-them-math-inline">$7$</span> 位图书 <span class="markdown-them-math-inline">$id$</span> ：可使用<code>printf(&quot;%07d\n&quot;, *it)</code></li></ul></li></ul><h2><span id="3-题解">3 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;map&lt;string, set&lt;<span class="hljs-keyword">int</span>&gt;&gt; title, author, key, pub, year;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(map&lt;string, set&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;m, string &amp;str)</span></span>&#123;    <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">find</span>(str) != m.<span class="hljs-built_in">end</span>())&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = m[str].<span class="hljs-built_in">begin</span>();it != m[str].<span class="hljs-built_in">end</span>();it++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%07d\n&quot;</span>, *it);        &#125;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Found\n&quot;</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// ONLINE_JUDGE</span></span>    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        <span class="hljs-keyword">int</span> id;        string ttitle, tauthor, tkey, tpub, tyear;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;id);        <span class="hljs-built_in">getline</span>(cin, ttitle);        title[ttitle].<span class="hljs-built_in">insert</span>(id);        <span class="hljs-built_in">getline</span>(cin, tauthor);        author[tauthor].<span class="hljs-built_in">insert</span>(id);        <span class="hljs-keyword">while</span>(cin &gt;&gt; tkey)&#123;            key[tkey].<span class="hljs-built_in">insert</span>(id);            <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getchar</span>();            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-built_in">getline</span>(cin, tpub);        pub[tpub].<span class="hljs-built_in">insert</span>(id);        <span class="hljs-built_in">getline</span>(cin, tyear);        year[tyear].<span class="hljs-built_in">insert</span>(id);    &#125;    <span class="hljs-keyword">int</span> m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;        <span class="hljs-keyword">int</span> num;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d: &quot;</span>, &amp;num);        string temp;        <span class="hljs-built_in">getline</span>(cin, temp);        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; temp &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">query</span>(title, temp);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">2</span>)&#123;            <span class="hljs-built_in">query</span>(author, temp);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">3</span>)&#123;            <span class="hljs-built_in">query</span>(key, temp);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">4</span>)&#123;            <span class="hljs-built_in">query</span>(pub, temp);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">5</span>)&#123;            <span class="hljs-built_in">query</span>(year, temp);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805480801550336&quot;&gt;1022 Digital Library (30分)&lt;/a&gt;&lt;/stro</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="PAT" scheme="https://leungll.site/tags/PAT/"/>
    
    <category term="Map映射" scheme="https://leungll.site/tags/Map%E6%98%A0%E5%B0%84/"/>
    
    <category term="输入数据处理" scheme="https://leungll.site/tags/%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【PAT甲级】1002 A+B for Polynomials &amp;&amp; 1009 Product of Polynomials</title>
    <link href="https://leungll.site/2020/05/30/pat-1002-1009/"/>
    <id>https://leungll.site/2020/05/30/pat-1002-1009/</id>
    <published>2020-05-30T14:13:56.000Z</published>
    <updated>2024-05-24T08:29:39.649Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="1-ab-for-polynomials">1 A+B for Polynomials</span></h2><p><strong>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000">1002 A+B for Polynomials</a></strong></p><blockquote><p>This time, you are supposed to find A+B where A and B are two polynomials.</p></blockquote><h3><span id="input-specification">Input Specification</span></h3><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br><span class="markdown-them-math-inline">$K\ N_1\ a_{​N​1}​​​​ N_2\ a_{​N​2}​​​​...\ N_K​\ a_{​N​K}​​​​$</span><br>where <span class="markdown-them-math-inline">$K$</span> is the number of nonzero terms in the polynomial, <span class="markdown-them-math-inline">$N​_i$</span>​​ and <span class="markdown-them-math-inline">$a​_{N​i}​​​​(i=1,2,⋯,K)$</span> are the exponents and coefficients, respectively. It is given that<br><span class="markdown-them-math-inline">$1 ≤ K ≤ 10，0 ≤ N​_K ​​&lt; ⋯ &lt; N_2 ​​&lt; N​_1 ≤ 1000$</span>.</p></blockquote><h3><span id="output-specification">Output Specification</span></h3><blockquote><p>For each test case you should output the sum of <span class="markdown-them-math-inline">$A$</span> and <span class="markdown-them-math-inline">$B$</span> in one line, with the same format as the input. Notice that there must be <strong>NO</strong> extra space at the end of each line. Please be accurate to 1 decimal place.</p></blockquote><h3><span id="sample-input">Sample Input</span></h3><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><h3><span id="sample-output">Sample Output</span></h3><blockquote><p>3 2 1.5 1 2.9 0 3.2</p></blockquote><h3><span id="解题思路">解题思路</span></h3><p>这道题有几个点需要注意：</p><ul><li>处理<strong>输入数据方式</strong>和常规有一些区别</li><li>coefficients 为<strong>浮点数</strong>且为<strong>负数时也要输出</strong></li><li>输出要精确到<strong>小数点后一位</strong></li><li>最后<strong>没有空格</strong></li></ul><h3><span id="题解">题解</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> a[maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// ONLINE_JUDGE</span></span>    <span class="hljs-keyword">int</span> k;    cin &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        <span class="hljs-keyword">int</span> exp;        <span class="hljs-keyword">double</span> coe;        cin &gt;&gt; exp &gt;&gt; coe;        a[exp] = coe;    &#125;    cin &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        <span class="hljs-keyword">int</span> exp;        <span class="hljs-keyword">double</span> coe;        cin &gt;&gt; exp &gt;&gt; coe;        a[exp] += coe;    &#125;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; maxn;i++)&#123;        <span class="hljs-keyword">if</span>(a[i])&#123;            cnt++;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = maxn;i &gt;= <span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-comment">//负数也需要输出</span>        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a[i];</span>            <span class="hljs-comment">//coe精确到小数点后一位</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %.1f&quot;</span>, i, a[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2><span id="2-product-of-polynomials">2 Product of Polynomials</span></h2><p><strong>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344">1009 Product of Polynomials</a></strong></p><blockquote><p>This time, you are supposed to find <span class="markdown-them-math-inline">$A×B$</span> where <span class="markdown-them-math-inline">$A$</span> and <span class="markdown-them-math-inline">$B$</span> are two polynomials.</p></blockquote><h3><span id="input-specification">Input Specification</span></h3><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br><span class="markdown-them-math-inline">$K\ N_1\ a_{​N​1}​​​​ N_2\ a_{​N​2}​​​​...\ N_K​\ a_{​N​K}​​​​$</span><br>where <span class="markdown-them-math-inline">$K$</span> is the number of nonzero terms in the polynomial, <span class="markdown-them-math-inline">$N​_i$</span>​​ and <span class="markdown-them-math-inline">$a​_{N​i}​​​​(i=1,2,⋯,K)$</span> are the exponents and coefficients, respectively. It is given that<br><span class="markdown-them-math-inline">$1 ≤ K ≤ 10，0 ≤ N​_K​ ​&lt; ⋯ &lt; N_2 ​​&lt; N​_1 ≤ 1000$</span>.</p></blockquote><h3><span id="output-specification">Output Specification</span></h3><blockquote><p>For each test case you should output the sum of <span class="markdown-them-math-inline">$A$</span> and <span class="markdown-them-math-inline">$B$</span> in one line, with the same format as the input. Notice that there must be <strong>NO</strong> extra space at the end of each line. Please be accurate to 1 decimal place.</p></blockquote><h3><span id="sample-input">Sample Input</span></h3><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><h3><span id="sample-output">Sample Output</span></h3><blockquote><p>3 3 3.6 2 6.0 1 1.6</p></blockquote><h3><span id="解题思路">解题思路</span></h3><p>注意一个坑：作为输出结果的 <span class="markdown-them-math-inline">$C[maxn2]$</span> 数组，范围需要开到 <span class="markdown-them-math-inline">$2000$</span> 以上才可。</p><h3><span id="题解">题解</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1005</span>, maxn2 = <span class="hljs-number">2010</span>;<span class="hljs-keyword">double</span> a[maxn] = &#123;<span class="hljs-number">0</span>&#125;, b[maxn] = &#123;<span class="hljs-number">0</span>&#125;, c[maxn2] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> k;    cin &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        <span class="hljs-keyword">int</span> exp;        <span class="hljs-keyword">double</span> coe;        cin &gt;&gt; exp &gt;&gt; coe;        a[exp] = coe;    &#125;    cin &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        <span class="hljs-keyword">int</span> exp;        <span class="hljs-keyword">double</span> coe;        cin &gt;&gt; exp &gt;&gt; coe;        b[exp] = coe;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; maxn;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; maxn;j++)&#123;            c[i + j] += a[i] * b[j];        &#125;    &#125;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; maxn2;i++)&#123;        <span class="hljs-keyword">if</span>(c[i])&#123;            cnt++;        &#125;    &#125;    cout &lt;&lt; cnt;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = maxn2;i &gt;= <span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">if</span>(c[i] != <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %.1f&quot;</span>, i, c[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;1-ab-for-polynomials&quot;&gt;1 A+B for Polynomials&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/99480534272086</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="PAT" scheme="https://leungll.site/tags/PAT/"/>
    
    <category term="多项式计算" scheme="https://leungll.site/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>【PAT甲级】1007 Maximum Subsequence Sum（最大连续子列和，dp）</title>
    <link href="https://leungll.site/2020/05/28/pat-1007/"/>
    <id>https://leungll.site/2020/05/28/pat-1007/</id>
    <published>2020-05-28T15:22:03.000Z</published>
    <updated>2024-05-03T13:53:17.913Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168">1007 Maximum Subsequence Sum</a></strong></p><h2><span id="1-题目描述">1 题目描述</span></h2><blockquote><p>Given a sequence of <span class="markdown-them-math-inline">$K$</span> integers {N​1​​, N​2, …, N​K​​}. A continuous subsequence is defined to be { N​i​​, N{​i+1}​​, …, Nj​​} where <span class="markdown-them-math-inline">$1 ≤ i ≤ j ≤ K$</span>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { <span class="markdown-them-math-inline">$-2, 11, -4, 13, -5, -2$</span> }, its maximum subsequence is { <span class="markdown-them-math-inline">$11, -4, 13$</span> } with the largest sum being <span class="markdown-them-math-inline">$20$</span>.<br>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p></blockquote><h3><span id="input-specification">Input Specification</span></h3><blockquote><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <span class="markdown-them-math-inline">$K (≤10000)$</span>. The second line contains <span class="markdown-them-math-inline">$K$</span> numbers, separated by a space.</p></blockquote><h3><span id="output-specification">Output Specification</span></h3><blockquote><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <span class="markdown-them-math-inline">$i$</span> and <span class="markdown-them-math-inline">$j$</span> (as shown by the sample case). <strong>If all the <span class="markdown-them-math-inline">$K$</span> numbers are negative, then its maximum sum is defined to be <span class="markdown-them-math-inline">$0$</span>, and you are supposed to output the first and the last numbers of the whole sequence.</strong></p></blockquote><h3><span id="sample-input">Sample Input</span></h3><div class="highlight"><pre class="code"><code>10<span class="hljs-string">-10</span> 1 2 3 4 <span class="hljs-string">-5</span> <span class="hljs-string">-23</span> 3 7 <span class="hljs-string">-21</span></code></pre></div><h3><span id="sample-output">Sample Output</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span></code></pre></div><h2><span id="2-解题思路">2 解题思路</span></h2><ul><li><p>题目大意：求最大连续子列和，输出最大的和以及这个子序列的开始值与结束值。如果所有的数都小于 <span class="markdown-them-math-inline">$0$</span> ， 则和为 <span class="markdown-them-math-inline">$0$</span> ，输出首尾元素。</p></li><li><p>注意题中有一个坑：</p><blockquote><p>If all the <span class="markdown-them-math-inline">$K$</span> numbers are negative, then its maximum sum is defined to be <span class="markdown-them-math-inline">$0$</span>, and you are supposed to output the first and the last numbers of the whole sequence.</p></blockquote><ul><li>如果数列为<code>5 -10  -20</code>，则输出结果应为<code>5, 5, 5</code></li><li>如果数列为<code>0 -3 0 </code>，则输出结果应为<code>0 0 0</code></li></ul></li></ul><h2><span id="3-题解">3 题解</span></h2><p>注意<code>int n, sum = -1, leftIndex = 0, rightIndex = n - 1;</code>中<code>n</code>与<code>rightIndex</code>不能声明在同一行。</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> arr[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">-1</span>, leftIndex = <span class="hljs-number">0</span>, rightIndex = n - <span class="hljs-number">1</span>, temp = <span class="hljs-number">0</span>, tempIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        cin &gt;&gt; arr[i];        temp += arr[i];        <span class="hljs-keyword">if</span>(temp &lt; <span class="hljs-number">0</span>)&#123;            temp = <span class="hljs-number">0</span>;            tempIndex = i + <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; temp)&#123;            sum = temp;            leftIndex = tempIndex;            rightIndex = i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>)&#123;        sum = <span class="hljs-number">0</span>;    &#125;    cout &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; arr[leftIndex] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; arr[rightIndex];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168&quot;&gt;1007 Maximum Subsequence Sum&lt;/a&gt;&lt;/st</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="PAT" scheme="https://leungll.site/tags/PAT/"/>
    
    <category term="最大连续子列和" scheme="https://leungll.site/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%88%97%E5%92%8C/"/>
    
    <category term="dp" scheme="https://leungll.site/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>【PAT甲级】1004 Counting Leaves （树的遍历，求每层叶子结点数）</title>
    <link href="https://leungll.site/2020/05/27/pat-1004/"/>
    <id>https://leungll.site/2020/05/27/pat-1004/</id>
    <published>2020-05-27T14:53:26.000Z</published>
    <updated>2024-05-03T13:46:55.552Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184">1004 Counting Leaves</a></strong></p><h2><span id="1-题目描述">1 题目描述</span></h2><blockquote><p>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.</p></blockquote><h3><span id="input-specification">Input Specification</span></h3><blockquote><p>Each input file contains one test case. Each case starts with a line containing <span class="markdown-them-math-inline">$0 &lt; N &lt; 100$</span>, the number of nodes in a tree, and <span class="markdown-them-math-inline">$M (&lt; N)$</span>, the number of non-leaf nodes. Then <span class="markdown-them-math-inline">$M$</span> lines follow, each in the format:</p><div class="highlight"><pre class="code"><code>ID K ID<span class="hljs-selector-attr">[1]</span> ID<span class="hljs-selector-attr">[2]</span> ... ID<span class="hljs-selector-attr">[K]</span></code></pre></div><p>where <code>ID</code> is a two-digit number representing a given non-leaf node, <code>K</code> is the number of its children, followed by a sequence of two-digit <code>ID</code>’s of its children. For the sake of simplicity, let us fix the root ID to be <code>01</code>.<br>The input ends with <span class="markdown-them-math-inline">$N$</span> being 0. That case must NOT be processed.</p></blockquote><h3><span id="output-specification">Output Specification</span></h3><blockquote><p>For each test case, you are supposed to count those family members who have no child <strong>for every seniority level</strong> starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.<br>The sample case represents a tree with only 2 nodes, where <code>01</code> is the root and <code>02</code> is its only child. Hence on the root <code>01</code> level, there is <code>0</code> leaf node; and on the next level, there is <code>1</code> leaf node. Then we should output <code>0 1</code> in a line.</p></blockquote><h3><span id="sample-input">Sample Input</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><span class="hljs-symbol">01 </span><span class="hljs-number">1</span> <span class="hljs-number">02</span></code></pre></div><h3><span id="sample-output">Sample Output</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-symbol">0 </span><span class="hljs-number">1</span></code></pre></div><h2><span id="2-解题思路">2 解题思路</span></h2><ul><li>给你一个家谱，找到没有孩子的人。即需要统计树中的叶子结点数量，可用 <span class="markdown-them-math-inline">$dfs$</span> 进行树的遍历操作。</li><li>采用<code>vector</code>进行存储树的结构，遍历<code>vector</code>，当<code>vector[i].size()==0</code>时，表明该结点没有叶子结点，所以它本身即为叶子结点。</li></ul><h2><span id="3-题解">3 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">105</span>;vector&lt;<span class="hljs-keyword">int</span>&gt; v[maxn];<span class="hljs-keyword">int</span> arr[maxn];<span class="hljs-keyword">int</span> maxDepth = <span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> depth)</span></span>&#123;    <span class="hljs-comment">//统计index节点是否为叶子结点</span>    <span class="hljs-keyword">if</span>(v[index].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//叶子结点数量加1</span>        arr[depth]++;        <span class="hljs-comment">//找出该树的最大层次</span>        maxDepth = <span class="hljs-built_in">max</span>(maxDepth, depth);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//如果index结点不是叶子结点，则遍历index的叶子结点</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; v[index].<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-built_in">dfs</span>(v[index][i], depth + <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// ONLINE_JUDGE</span></span>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>();cout.<span class="hljs-built_in">tie</span>();    <span class="hljs-keyword">int</span> n, m;    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;            <span class="hljs-keyword">int</span> node, k;            cin &gt;&gt; node &gt;&gt; k;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; k;j++)&#123;                <span class="hljs-keyword">int</span> temp;                cin &gt;&gt; temp;                v[node].<span class="hljs-built_in">push_back</span>(temp);            &#125;        &#125;    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    cout &lt;&lt; arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= maxDepth;i++)&#123;        cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; arr[i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805521431773184&quot;&gt;1004 Counting Leaves&lt;/a&gt;&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="PAT" scheme="https://leungll.site/tags/PAT/"/>
    
    <category term="树的遍历" scheme="https://leungll.site/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
    <category term="求叶子结点数" scheme="https://leungll.site/tags/%E6%B1%82%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>最短路径算法之 Dijkstra &amp;&amp; BellmanFord（模板）</title>
    <link href="https://leungll.site/2020/05/26/dijkstra-bellmanFord/"/>
    <id>https://leungll.site/2020/05/26/dijkstra-bellmanFord/</id>
    <published>2020-05-26T13:21:06.000Z</published>
    <updated>2025-01-05T07:08:05.072Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-dijkstra%E7%AE%97%E6%B3%95">1 Dijkstra算法</a><ul><li><a href="#11-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF">1.1 算法模板</a></li><li><a href="#12-%E4%BE%8B%E9%A2%98">1.2 例题</a><ul><li><a href="#problem-description">Problem Description</a></li><li><a href="#input-specification">Input Specification</a></li><li><a href="#output-specification">Output Specification</a></li><li><a href="#sample-input">Sample Input</a></li><li><a href="#sample-output">Sample Output</a></li><li><a href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F">题目大意</a></li><li><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</a></li><li><a href="#%E9%A2%98%E8%A7%A3">题解</a></li></ul></li></ul></li><li><a href="#2-bellmanford">2 BellmanFord</a><ul><li><a href="#21-%E8%AE%B2%E8%A7%A3">2.1 讲解</a></li><li><a href="#22-%E4%BE%8B%E9%A2%98">2.2 例题</a><ul><li><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li><li><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">输入格式</a></li><li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">输出格式</a></li><li><a href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5">样例输入</a></li><li><a href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA">样例输出</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E4%B8%8E%E7%BA%A6%E5%AE%9A">数据规模与约定</a></li><li><a href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1">解题思路</a></li><li><a href="#%E9%A2%98%E8%A7%A3-1">题解</a></li></ul></li></ul></li></ul><!-- tocstop --><h2><span id="1-dijkstra算法">1 Dijkstra算法</span></h2><blockquote><p>适用范围：不能解决带有负边的图</p></blockquote><h3><span id="11-算法模板">1.1 算法模板</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iosream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 205</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 1e18</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 0.00001</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> ll mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);ll n, vis[maxn][maxn], dis[maxn];<span class="hljs-keyword">bool</span> flag[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span> </span>&#123;    ll now = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;        dis[i] = inf;    &#125;    flag[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        ll temp = inf;        <span class="hljs-comment">//找到当前轮次最小的dis[j]顶点即为now</span>        <span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">1</span> ; j &lt;= n; j++) &#123;            <span class="hljs-keyword">if</span>(flag[j] == <span class="hljs-number">0</span> &amp;&amp; dis[j] &lt; temp) &#123;                temp = dis[j];                now = j;            &#125;        &#125;        flag[now] = <span class="hljs-number">1</span>;        <span class="hljs-comment">//更新与now相连顶点的dis值</span>        <span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;            dis[j] = <span class="hljs-built_in">min</span>(dis[j], dis[now] + vis[now][j]);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;            vis[i][j] = inf;        &#125;    &#125;    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">1</span>; j &lt;= n - i; j++) &#123;            ll temp;            cin &gt;&gt; temp;            vis[i][i + j] = temp;            <span class="hljs-keyword">if</span>(i == j)&#123;                vis[i][j] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-built_in">dij</span>();    cout &lt;&lt; dis[n] &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3><span id="12-例题">1.2 例题</span></h3><blockquote><p><strong>题目链接：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003 Emergency (25分)</a></strong></p></blockquote><h4><span id="problem-description">Problem Description</span></h4><blockquote><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p></blockquote><h4><span id="input-specification">Input Specification</span></h4><blockquote><p>Each input file contains one test case. For each test case, the first line contains <span class="markdown-them-math-inline">$4$</span> positive integers: <span class="markdown-them-math-inline">$N (≤500)$</span> - the number of cities (and the cities are numbered from <span class="markdown-them-math-inline">$0$</span> to <span class="markdown-them-math-inline">$N−1$</span>), <span class="markdown-them-math-inline">$M$</span> - the number of roads, <span class="markdown-them-math-inline">$C​1$</span>​​ and <span class="markdown-them-math-inline">$C​2$</span>​​ - the cities that you are currently in and that you must save, respectively. The next line contains <span class="markdown-them-math-inline">$N$</span> integers, where the i-th integer is the number of rescue teams in the <span class="markdown-them-math-inline">$i$</span>-th city. Then <span class="markdown-them-math-inline">$M$</span> lines follow, each describes a road with three integers <span class="markdown-them-math-inline">$c​1$</span>​​, <span class="markdown-them-math-inline">$c​2$</span>​​ and <span class="markdown-them-math-inline">$L$</span>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <span class="markdown-them-math-inline">$C​1$</span>​​ to <span class="markdown-them-math-inline">$C​2$</span>​​.</p></blockquote><h4><span id="output-specification">Output Specification</span></h4><blockquote><p>For each test case, print in one line two numbers: the number of different shortest paths between <span class="markdown-them-math-inline">$C​1$</span>​​ and <span class="markdown-them-math-inline">$C​2​​$</span>, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p></blockquote><h4><span id="sample-input">Sample Input</span></h4><div class="highlight"><pre class="code"><code><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">0 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span></code></pre></div><h4><span id="sample-output">Sample Output</span></h4><div class="highlight"><pre class="code"><code><span class="hljs-symbol">2 </span><span class="hljs-number">4</span></code></pre></div><h4><span id="题目大意">题目大意</span></h4><p>给出 <span class="markdown-them-math-inline">$N$</span> 个城市，及每个城市的救援队数量，你在 <span class="markdown-them-math-inline">$C1$</span> 点，需要去救援 <span class="markdown-them-math-inline">$C2$</span> 点，目标是找出权重最小的不同路径数及能召集到最多救援队的数量。</p><h4><span id="解题思路">解题思路</span></h4><p>用 <span class="markdown-them-math-inline">$Dijkstra$</span> 求出最小路径数，并增加救援队数量以及不同路径数的条件判断即可。</p><h4><span id="题解">题解</span></h4><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0X3f3f3f3f</span>;<span class="hljs-comment">//城市救援队数量，不同的路径数，边的权重</span><span class="hljs-keyword">int</span> arr[maxn] = &#123;<span class="hljs-number">0</span>&#125;, ans[maxn], num[maxn], cost[maxn][maxn], dis[maxn], vis[maxn];<span class="hljs-keyword">int</span> n, m, c1, c2;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dij</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//初始化</span>    dis[c1] = <span class="hljs-number">0</span>;    num[c1] = arr[c1];    ans[c1] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        <span class="hljs-keyword">int</span> now, temp = INF;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;            <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; temp)&#123;                temp = dis[j];                now = j;            &#125;        &#125;        <span class="hljs-comment">//找到最小距离</span>        vis[now] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;            <span class="hljs-comment">//如果遍历的顶点与找到最小距离的顶点重复，跳过，否则答案有误</span>            <span class="hljs-keyword">if</span>(j == now)&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">//最短距离相同时，累加</span>            <span class="hljs-keyword">if</span>(dis[j] == dis[now] + cost[now][j])&#123;                ans[j] += ans[now];                num[j] = <span class="hljs-built_in">max</span>(num[j], num[now] + arr[j]);            &#125;            <span class="hljs-keyword">if</span>(dis[j] &gt; dis[now] + cost[now][j])&#123;                dis[j] = dis[now] + cost[now][j];                ans[j] = ans[now];                num[j] = num[now] + arr[j];            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-built_in">memset</span>(dis, INF, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dis));    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));    <span class="hljs-built_in">memset</span>(num, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num));    <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        cin &gt;&gt; arr[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span>(i == j)                cost[i][j] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span>                cost[i][j] = INF;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;        <span class="hljs-keyword">int</span> a, b, l;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; l;        cost[a][b] = cost[b][a] = l;    &#125;    <span class="hljs-built_in">dij</span>();    cout &lt;&lt; ans[c2] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; num[c2];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2><span id="2-bellmanford">2 BellmanFord</span></h2><h3><span id="21-讲解">2.1 讲解</span></h3><ul><li><p>适用范围</p><ul><li>BellmanFord 算法适合含有<strong>负权</strong>的<strong>大图</strong>求最短路径 。</li><li>但如果存在从源点可达的负权值回路（负回路），则最短路径不存在。因为可以重复走这个回路，使得路径无穷小。</li></ul></li><li><p>松弛操作</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/dijkstra-bellmanFord-01.png" alt="dijkstra-bellmanFord-01"></p></li></ul><h3><span id="22-例题">2.2 例题</span></h3><blockquote><p><strong>题目链接：<a href="http://lx.lanqiao.cn/problem.page?gpid=T15">http://lx.lanqiao.cn/problem.page?gpid=T15</a></strong></p></blockquote><h4><span id="问题描述">问题描述</span></h4><blockquote><p>给定一个 n 个顶点，m 条边的有向图（其中某些边权可能为负，但保证没有负环）。请你计算从 1 号点到其他点的最短路（顶点从 1 到 n 编号）。</p></blockquote><h4><span id="输入格式">输入格式</span></h4><blockquote><p>第一行两个整数 n, m。<br>接下来的 m 行，每行有三个整数 u, v, l，表示 u 到 v 有一条长度为 l 的边。</p></blockquote><h4><span id="输出格式">输出格式</span></h4><blockquote><p>共 n - 1 行，第 i 行表示 1 号点到 i + 1 号点的最短路。</p></blockquote><h4><span id="样例输入">样例输入</span></h4><div class="highlight"><pre class="code"><code><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> -<span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> </code></pre></div><h4><span id="样例输出">样例输出</span></h4><div class="highlight"><pre class="code"><code><span class="hljs-deletion">-1</span><span class="hljs-deletion">-2 </span></code></pre></div><h4><span id="数据规模与约定">数据规模与约定</span></h4><blockquote><p>对于 10% 的数据，n = 2，m = 2。<br>对于 30% 的数据，n &lt;= 5，m &lt;= 10。<br>对于 100% 的数据，1 &lt;= n &lt;= 20000，1 &lt;= m &lt;= 200000，-10000 &lt;= l &lt;= 10000，保证从任意顶点都能到达其他所有顶点。</p></blockquote><h4><span id="解题思路">解题思路</span></h4><p>求图的最短路径，但是图中有负边，且图的规模很大，因此考虑使用 <span class="markdown-them-math-inline">$Bellman-Ford$</span> 算法。</p><h4><span id="题解">题解</span></h4><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200005</span>;<span class="hljs-keyword">int</span> u[maxn], v[maxn], w[maxn], dis[maxn], path[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> n, m;cin &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)&#123;cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;dis[i] = INF;&#125;<span class="hljs-comment">//将一号顶点置为0</span>dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//从 dist(0)[u] 递推出 dist(n-1)[u] 循环n-1次</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n - <span class="hljs-number">1</span>;i++)&#123;<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;x &lt;= n;x++)&#123;path[x] = dis[x];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++)&#123;<span class="hljs-comment">//顶点到 v[j]顶点的路径 &gt; u[j]顶点到 v[j] 的距离 + u[j]到 v[j]边的权值</span><span class="hljs-keyword">if</span>(dis[v[j]] &gt; dis[u[j]] + w[j])&#123;dis[v[j]] = dis[u[j]] + w[j];&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;a &lt;= n;a++)&#123;<span class="hljs-keyword">if</span>(path[a] != dis[a])&#123;flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span>(!flag)&#123;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i++)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dis[i]);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125; </code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-dijkstra%E7%AE%97%E6%B3%95&quot;&gt;1 Dijkstra算法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF&quot;&gt;1</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="PAT" scheme="https://leungll.site/tags/PAT/"/>
    
    <category term="蓝桥杯" scheme="https://leungll.site/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="Dijkstra" scheme="https://leungll.site/tags/Dijkstra/"/>
    
    <category term="BellmanFord" scheme="https://leungll.site/tags/BellmanFord/"/>
    
  </entry>
  
  <entry>
    <title>PAT - 线上测试赛( 2020-05-01 ) - 题解</title>
    <link href="https://leungll.site/2020/05/06/pat-test/"/>
    <id>https://leungll.site/2020/05/06/pat-test/</id>
    <published>2020-05-06T14:38:30.000Z</published>
    <updated>2024-05-03T13:55:21.157Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="1-knuth洗牌法-20分">1 Knuth洗牌法 (20分)</span></h2><p><strong>题目描述</strong></p><blockquote><p>Knuth 洗牌法是生成 { 1, 2, …, n } 的一个随机重排列的算法。与每次反复随机生成一个数字，直到获得一个不重复的新数字的算法不同，Knuth 洗牌法从原始序列 { 1, 2, …, n } 开始，逐次洗牌。洗牌的方法是从左到右，每轮从没确定的数字中随机抽取一个数，把它放到确定的位置上。<br>例如令 n 等于 4。我们从 { 1, 2, 3, 4 } 开始。记 i 到 N 之间的随机抽牌数为 random(i, N)。假设我们生成的随机数序列 random(i, 4) (i = 1, 2, 3, 4) 为 { 2, 4, 3, 4 }。则 Knuth 洗牌法是这样执行的：</p><ul><li>random(1, 4) = 2; 将位置 1 与位置 2 的数字交换，得到 { 2, 1, 3, 4 }</li><li>random(2, 4) = 4; 将位置 2 与位置 4 的数字交换，得到 { 2, 4, 3, 1 }</li><li>random(3, 4) = 3; 将位置 3 与位置 3 的数字交换，得到 { 2, 4, 3, 1 }</li><li>random(4, 4) = 4; 将位置 4 与位置 4 的数字交换，得到 { 2, 4, 3, 1 }</li></ul><p>现给定随机抽牌数字序列，请你输出 Knuth 洗牌法的结果序列。</p></blockquote><p><strong>输入格式</strong></p><blockquote><p>输入在第一行中给出一个正整数 N（≤ 1000）。随后一行给出 N 个随机抽牌数字，数字间以空格分隔。题目保证第 i 个数在 i 到 N 之间。</p></blockquote><p><strong>输出格式</strong></p><blockquote><p>在第一行中输出 Knuth 洗牌法的结果序列。数字间必须以 1 个空格分隔，行首尾不得有多余空格。</p></blockquote><p><strong>输入样例</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-number">10</span><span class="hljs-symbol">7 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span></code></pre></div><p><strong>输出样例</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-symbol">7 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">8</span></code></pre></div><p><strong>思路</strong></p><p>水题，用三变量交换法，交换数组的值即可。</p><p><strong>题解</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> a[maxn] = &#123;<span class="hljs-number">0</span>&#125;, b[maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];        b[i] = i;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">int</span> t1 = i, t2 = a[i];        <span class="hljs-keyword">int</span> temp = b[t1];        b[t1] = b[t2];        b[t2] = temp;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) &#123;            cout &lt;&lt; b[i];        &#125; <span class="hljs-keyword">else</span> &#123;            cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2><span id="2-三阶幸福数-20分">2 三阶幸福数 (20分)</span></h2><p><strong>题目描述</strong></p><blockquote><p>对一个十进制数的各位数字做一次立方和，称作一次迭代。如果一个十进制数能通过 h 次迭代得到 1，就称该数为三阶幸福数，迭代的次数 h 称为幸福度。例如 1579 经过 1 次迭代得到 1198，2 次迭代后得到 1243，3 次迭代后得到 100，最后得到 1。则 1579 是幸福数，其幸福度为 4。<br>另一方面，如果一个大于1的数字经过数次迭代后进入了死循环，那这个数就不幸福。例如 97 迭代得到 1072、352、160、217、352、…… 可见 352 到 217 形成了死循环，所以 97 就不幸福，而 352 就是它最早遇到的循环点。<br>本题就要求你编写程序，判断一个给定的数字是否有三阶幸福。</p></blockquote><p><strong>输入格式</strong></p><blockquote><p>输入在第一行给出一个不超过 100 的正整数 N，随后 N 行，每行给出一个不超过 <span class="markdown-them-math-inline">$10^{4}$</span>​​ 的正整数。</p></blockquote><p><strong>输出格式</strong></p><blockquote><p>对于每一个输入的数字，如果其是三阶幸福数，则在一行中输出它的幸福度；否则输出最早遇到的循环点。</p></blockquote><p><strong>输入样例</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-number">3</span><span class="hljs-number">1579</span><span class="hljs-number">97</span><span class="hljs-number">1</span></code></pre></div><p><strong>输出样例</strong></p><div class="highlight"><pre class="code"><code>43520</code></pre></div><p><strong>思路</strong></p><ul><li>用 <span class="markdown-them-math-inline">$set$</span> 存储每次迭代生成的数据，如果 <span class="markdown-them-math-inline">$sum$</span> 为 <span class="markdown-them-math-inline">$1$</span>，输出 <span class="markdown-them-math-inline">$ans$</span> ，跳出循环。如果找到相同的值，则输出。</li><li>注意 <span class="markdown-them-math-inline">$17$</span> 行，对 <span class="markdown-them-math-inline">$st$</span> 清空操作。</li><li>注意对特例 <span class="markdown-them-math-inline">$1$</span> 的处理。</li></ul><p><strong>题解</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;set&lt;<span class="hljs-keyword">int</span>&gt; st;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">int</span> num, ans = <span class="hljs-number">0</span>;        st.<span class="hljs-built_in">clear</span>();        cin &gt;&gt; num;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;            st.<span class="hljs-built_in">insert</span>(num);            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(num) &#123;                sum += (num % <span class="hljs-number">10</span>) * (num % <span class="hljs-number">10</span>) * (num % <span class="hljs-number">10</span>);                num /= <span class="hljs-number">10</span>;            &#125;            ans++;            <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">1</span>) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">find</span>(sum) != st.<span class="hljs-built_in">end</span>()) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);                <span class="hljs-keyword">break</span>;            &#125;            num = sum;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2><span id="3-垃圾分类-20分">3 垃圾分类 (20分)</span></h2><p><strong>题目描述</strong></p><blockquote><p>据香港《南华早报》2019 年 7 月 15 日文章，上海严格的垃圾分类新规令不少居民抓狂。这催生出大量帮助找出正确分类答案的 App 和小程序。目前仅微信上就至少有 280 种与垃圾处理有关的 App，在苹果应用商店也达 130 种。支付宝表示，已有 60 多家独立 App 开发商申请为该平台提供类似服务。<br>本题就请你现场实现一个简单的垃圾分类小助手。</p></blockquote><p><strong>输入格式</strong></p><blockquote><p>输入首先给出官方分类指南中每种物品的归属。在一行中给出一个正整数 N（≤ <span class="markdown-them-math-inline">$10​^5$</span>​​），即物品数量；随后 N 行，每行给出一个物品名称（长度不超过 10 的、由小写英文字母和下划线组成的字符串）和该物品所属的分类（1 代表干垃圾、2 代表湿垃圾、3 代表可回收物、4 代表有害垃圾）。题目保证所有物品名称无重复。<br>随后每行给出一个查询物品的名称（格式与指南物品名称相同）。最后一行给出结束符<code>#</code>，表示查询终止，这一行不需要查询。</p></blockquote><p><strong>输出格式</strong></p><blockquote><p>对每个查询的物品，在一行中给出其所属分类：<code>Gan laji</code> 代表干垃圾；<code>Shi laji</code> 代表湿垃圾；<code>Ke Hui Shou</code> 代表可回收物；<code>You Hai laji</code> 代表有害垃圾。如果查询的物品不在指南中，则输出 <code>?</code> 表示不知道。</p></blockquote><p><strong>输入样例</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-number">4</span><span class="hljs-keyword">bao_zhi </span><span class="hljs-number">3</span><span class="hljs-keyword">dian_chi </span><span class="hljs-number">4</span>dan_ke <span class="hljs-number">2</span><span class="hljs-keyword">bei_ke </span><span class="hljs-number">1</span>dan_ke<span class="hljs-keyword">dian_chi</span>ren_zha<span class="hljs-keyword">bao_zhi</span><span class="hljs-keyword">bei_ke</span>#</code></pre></div><p><strong>输出样例</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-keyword">Shi </span>lajiYou Hai laji?Ke Hui <span class="hljs-keyword">Shou</span>Gan laji</code></pre></div><p><strong>思路</strong></p><ul><li>用一个 <span class="markdown-them-math-inline">$char$</span> 数组和 <span class="markdown-them-math-inline">$map$</span> 存储，反向取值即可。</li><li>注意 <span class="markdown-them-math-inline">$23$</span> 行，存在多次输入时，用 <span class="markdown-them-math-inline">$cin$</span> 会运行超时。</li></ul><p><strong>题解</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">char</span> chr[<span class="hljs-number">5</span>][<span class="hljs-number">20</span>] = &#123;<span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;Gan laji&quot;</span>, <span class="hljs-string">&quot;Shi laji&quot;</span>,<span class="hljs-string">&quot;Ke Hui Shou&quot;</span>,<span class="hljs-string">&quot;You Hai laji&quot;</span>&#125;;map&lt;string, <span class="hljs-keyword">int</span>&gt; mp;<span class="hljs-keyword">char</span> str[<span class="hljs-number">20</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        <span class="hljs-keyword">int</span> num;        cin &gt;&gt; str &gt;&gt; num;        mp[str] = num;    &#125;<span class="hljs-comment">//    while((cin &gt;&gt; str) &amp;&amp; (str != &quot;#&quot;))&#123;</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str) != EOF &amp;&amp; <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;#&quot;</span>, str) != <span class="hljs-number">0</span>)&#123;        <span class="hljs-built_in">puts</span>(chr[mp[str]]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/leungll/ImgHosting/img/pat-test-01.png" alt="pat-test-01"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;1-knuth洗牌法-20分&quot;&gt;1 Knuth洗牌法 (20分)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Knuth 洗牌法是生成 { 1, 2, …, n } 的一个随机重排列</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="PAT" scheme="https://leungll.site/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>【洛谷 1072 &amp;&amp; 蓝桥杯 算法训练 ALGO - 37】Hankson 的趣味题（数论）</title>
    <link href="https://leungll.site/2020/04/28/algo-28/"/>
    <id>https://leungll.site/2020/04/28/algo-28/</id>
    <published>2020-04-28T15:15:40.000Z</published>
    <updated>2024-05-24T06:59:55.775Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T99">http://lx.lanqiao.cn/problem.page?gpid=T99</a></p></blockquote><h1><span id="1-题目">1 题目</span></h1><h2><span id="题目描述">题目描述</span></h2><blockquote><p>Hanks 博士是 BT (Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。 今天在课堂上，老师讲解了如何求两个正整数 c1 和 c2 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 a0, a1, b0, b1，设某未知正整数 x 满足：</p><ul><li><ol><li>x 和 a0 的最大公约数是 a1；</li></ol></li><li><ol start="2"><li>x 和 b0 的最小公倍数是 b1；</li></ol></li></ul><p>Hankson 的“逆问题”就是求出满足条件的正整数 x。但稍加思索之后，他发现这样的 x 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 x 的个数。请你帮助他编程求解这个问题。</p></blockquote><h2><span id="输入格式">输入格式</span></h2><blockquote><p>输入第一行为一个正整数 n，表示有 n 组输入数据。<br>接下来的 n 行每行一组输入数据，为四个正整数 a0，a1，b0，b1，每两个整数之间用一个空格隔开。输入数据保证 a0 能被 a1 整除，b1 能被 b0 整除。</p></blockquote><h2><span id="输出格式">输出格式</span></h2><blockquote><p>输出共 n 行。每组输入数据的输出结果占一行，为一个整数。<br>对于每组数据：若不存在这样的 x ，请输出 0 ； 若存在这样的 x ，请输出满足条件的 x 的个数；</p></blockquote><h2><span id="样例输入">样例输入</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-number">2</span><span class="hljs-symbol">41 </span><span class="hljs-number">1</span> <span class="hljs-number">96</span> <span class="hljs-number">288</span><span class="hljs-symbol">95 </span><span class="hljs-number">1</span> <span class="hljs-number">37</span> <span class="hljs-number">1776</span></code></pre></div><h2><span id="样例输出">样例输出</span></h2><div class="highlight"><pre class="code"><code>62</code></pre></div><h2><span id="样例说明">样例说明</span></h2><blockquote><p>第一组输入数据，x 可以是 9、18、36、72、144、288，共有 6 个。<br>第二组输入数据，x 可以是 48、1776，共有 2 个。</p></blockquote><h1><span id="2-分析">2 分析</span></h1><blockquote><p>首先，直接暴力枚举只能过 <span class="markdown-them-math-inline">$50\%$</span> 的数据。</p></blockquote><p><strong>1. 关于两个定理：</strong></p><ul><li><p>最大公约数</p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;       <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);     &#125;</code></pre></div></li><li><p>最小公倍数</p><div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> a * b / <span class="hljs-built_in">gcd</span>(a, b);&#125;</code></pre></div></li></ul><p><strong>2. 一个结论</strong>：设 <span class="markdown-them-math-inline">$gcd(x, a_0)=a_1$</span> ，并有</p><div class="markdown-them-math-block">$$    \left\{        \begin{aligned}            x=k_{1}*a_{1} \\             a_{0}=k_{2}*a_{1}&amp;        \end{aligned}    \right.$$</div><p>则 <span class="markdown-them-math-inline">$gcd(k_1,k_2)=1$</span> 。</p><p><strong>证明：</strong></p><ul><li><p>假设 <span class="markdown-them-math-inline">$gcd(k_1,k_2)\neq1$</span>，<span class="markdown-them-math-inline">$gcd(k_1,k_2)=K$</span>，并有</p><div class="markdown-them-math-block">$$    \left\{        \begin{aligned}            k_{1}=p*K \\             k_{2}=q*K&amp;        \end{aligned}    \right.$$</div></li><li><p>由假设得：</p><div class="markdown-them-math-block">$$    \left\{        \begin{aligned}            x=p*K*a_{1} \\             a_{0}=q*K*a_{1}&amp;        \end{aligned}    \right.$$</div></li><li><p>可得 <span class="markdown-them-math-inline">$gcd(x,a_0)=K*a_1\neq a_1$</span>，结果与题目条件不符，假设不成立</p></li><li><p>则 <span class="markdown-them-math-inline">$gcd(k_1,k_2)=1$</span></p></li></ul><p>因此可得：</p><blockquote><p>对于两个正整数 <span class="markdown-them-math-inline">$a,b$</span> ，设 <span class="markdown-them-math-inline">$gcd(a,b)=k$</span> 则存在 <span class="markdown-them-math-inline">$gcd(a / k,b / k)=1$</span></p></blockquote><p><strong>3. 推导</strong></p><ul><li><p>由最大公约数定理</p><div class="markdown-them-math-block">$$    gcd(x,a_{0})=a_{1}$$</div><p>得</p><div class="markdown-them-math-block">$$    gcd(\frac {x} {a_{1}} ,\frac {a_{0}}{a_{1}})=1$$</div></li><li><p>由最小公倍数定理</p><div class="markdown-them-math-block">$$    lcm(x,b_{0})=b_{1}=\frac {x*b_{0}}{gcd(x,b_{0})}$$</div><p>则</p><div class="markdown-them-math-block">$$    gcd(x,b_{0})=\frac{x*b_{0}}{b_{1}}$$</div><p>得</p><div class="markdown-them-math-block">$$    gcd(\frac {b_1} {b_{0}} ,\frac {b_{1}}{x})=1$$</div></li></ul><p><strong>4. 最终可得如下结论：</strong></p><div class="markdown-them-math-block">$$    \left\{        \begin{aligned}            gcd(\frac {x} {a_{1}} ,\frac {a_{0}}{a_{1}})=1 \\             gcd(\frac {b_1} {b_{0}} ,\frac {b_{1}}{x})=1&amp;        \end{aligned}    \right.$$</div><h1><span id="3-题解">3 题解</span></h1><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-keyword">int</span> a0, a1, b0, b1, ans = <span class="hljs-number">0</span>;        cin &gt;&gt; a0 &gt;&gt; a1 &gt;&gt; b0 &gt;&gt; b1;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;x &lt;= <span class="hljs-built_in">sqrt</span>(b1);x++)&#123;            <span class="hljs-keyword">if</span>(b1 % x == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(x % a1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">gcd</span>(x / a1, a0 / a1) == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">gcd</span>(b1 / x, b1 / b0) == <span class="hljs-number">1</span>)&#123;                    ans++;                &#125;                <span class="hljs-comment">//枚举另一个因子 </span>                <span class="hljs-keyword">int</span> y = b1 / x;                <span class="hljs-keyword">if</span>(y == x)&#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(y % a1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">gcd</span>(y / a1, a0 / a1) == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">gcd</span>(b1 / y, b1 / b0) == <span class="hljs-number">1</span>)&#123;                    ans++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(ans != <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://lx.lanqiao.cn/problem.page?gpid=T99&quot;&gt;http://lx.lanqiao.cn/problem.page?gpid=T99&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="蓝桥杯" scheme="https://leungll.site/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="数论" scheme="https://leungll.site/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法之动态规划篇</title>
    <link href="https://leungll.site/2020/04/11/dp/"/>
    <id>https://leungll.site/2020/04/11/dp/</id>
    <published>2020-04-11T16:35:20.000Z</published>
    <updated>2025-01-05T07:08:02.133Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-dp%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8">1 dp基本性质</a></li><li><a href="#2-%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98">2 装箱问题</a></li><li><a href="#3-%E5%BC%80%E5%BF%83%E7%9A%84%E9%87%91%E6%98%8E01%E8%83%8C%E5%8C%85">3 开心的金明(0/1背包)</a></li><li><a href="#4-%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BAdfs%E5%AE%9E%E7%8E%B0">4 数的划分(分类讨论，dfs实现）</a></li><li><a href="#5-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97dfs%E5%AE%9E%E7%8E%B0">5 摆动序列(dfs实现）</a></li><li><a href="#6-%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%BD%A2dp">6 传球游戏(环形dp)</a></li><li><a href="#7-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E5%A4%9A%E7%BA%BF%E7%A8%8Bdp">7 方格取数(多线程dp）</a></li><li><a href="#8-k%E5%A5%BD%E6%95%B0">8 K好数</a></li></ul><!-- tocstop --><h2><span id="1-dp基本性质">1 dp基本性质</span></h2><ul><li><p><strong>最优子结构</strong></p><ul><li>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的<strong>最优子结构性质</strong>提供了该问题可用动态规划算法求解的重要线索。</li><li>在动态规划算法中，利用问题的最优子结构性质，以<strong>自底向上</strong>的方式递归地从<strong>子问题</strong>的最优解逐步构造出<strong>整个问题的最优解</strong>。</li></ul></li><li><p><strong>重叠子问题</strong></p><ul><li>子问题之间是不独立的，一个子问题在下一阶段决策中可能被<strong>多次使用</strong>。对每个子问题只解一次，而后将其保存在一个表格中，当再次需要的时候，只是简单的用<strong>常数时间</strong>查看一下结果。</li></ul></li><li><p><strong>无后效性</strong></p><ul><li>即某阶段状态一旦确定，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，<strong>只与当前状态有关</strong>。</li></ul></li></ul><h2><span id="2-装箱问题">2 装箱问题</span></h2><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T83">http://lx.lanqiao.cn/problem.page?gpid=T83</a></p><p><strong>题目大意</strong>：</p><blockquote><p>有一个箱子容量为 V（正整数，0 ＜＝ V ＜＝ 20000），同时有 n 个物品（0 ＜ n ＜＝ 30），每个物品有一个体积（正整数）。<br>要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p></blockquote><p><strong>解题思路</strong>：</p><p>最经典的 <span class="markdown-them-math-inline">$dp$</span> 问题，直接上手</p><ul><li><span class="markdown-them-math-inline">$dp[j]$</span>：当体积为 <span class="markdown-them-math-inline">$j$</span> 时，最大填充为 <span class="markdown-them-math-inline">$dp[j]$</span></li><li><span class="markdown-them-math-inline">$dp$</span> 方程：</li></ul><div class="markdown-them-math-block">$$dp[j] = max(dp[j], dp[\, j - w[i] \,] + w[i])$$</div><p><strong>题解</strong>：</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">20010</span>;<span class="hljs-comment">//dp[j]：当体积为j时，最大填充为dp[j] </span><span class="hljs-keyword">int</span> dp[maxn], w[<span class="hljs-number">35</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span>    <span class="hljs-keyword">int</span> v, n;    cin &gt;&gt; v &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        cin &gt;&gt; w[i];    &#125;    <span class="hljs-comment">//n个物品 </span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        <span class="hljs-comment">//总体积为v </span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = v;j &gt;= w[i];j--)&#123;            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + w[i]);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, v - dp[v]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*24683127970*/</span></code></pre></div><h2><span id="3-开心的金明01背包">3 开心的金明(0/1背包)</span></h2><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T93">http://lx.lanqiao.cn/problem.page?gpid=T93</a></p><p><strong>题目大意</strong>：</p><blockquote><p>在不超过 <span class="markdown-them-math-inline">$N$</span> 元（可以等于 <span class="markdown-them-math-inline">$N$</span> 元）的前提 下，使每件物品的价格与重要度的乘积的总和最大。</p></blockquote><p><strong>解题思路</strong>：</p><p>约定，<span class="markdown-them-math-inline">$dp[i][j]$</span> 表示判定了 <span class="markdown-them-math-inline">$i$</span> 件物品，剩余钱数为 <span class="markdown-them-math-inline">$j$</span> 时，每件物品的价格与重要度的乘积的总和最大。</p><ul><li><p>典型的 <strong><span class="markdown-them-math-inline">$0/1$</span> 背包</strong>问题</p></li><li><p><span class="markdown-them-math-inline">$dp$</span> 方程：</p><div class="markdown-them-math-block">$$    dp[i][j] = max( dp[i - 1][j], \,dp[i - 1][j - v] + v * p)$$</div><p>其中，<span class="markdown-them-math-inline">$v$</span> 表示物品的价格，<span class="markdown-them-math-inline">$p$</span> 表示该物品的重要度。</p></li></ul><p><strong>题解</strong>：</p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">30005</span>;<span class="hljs-comment">//dp[i][j]表示判定了i件物品，剩余钱数为j时，每件物品的价格与重要度的乘积的总和最大</span><span class="hljs-keyword">int</span> dp[<span class="hljs-number">30</span>][maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-comment">//物品件数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)&#123;        <span class="hljs-keyword">int</span> v, p;        cin &gt;&gt; v &gt;&gt; p;        <span class="hljs-comment">//总钱数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123;            <span class="hljs-keyword">if</span>(j &gt;= v)&#123;                dp[i][j] = <span class="hljs-built_in">max</span>( dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - v] + v * p);            &#125;<span class="hljs-keyword">else</span>&#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];            &#125;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[m][n]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*1000 5800 2400 5300 5400 3200 23900*/</span></code></pre></div><h2><span id="4-数的划分分类讨论dfs实现">4 数的划分(分类讨论，dfs实现）</span></h2><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T84">http://lx.lanqiao.cn/problem.page?gpid=T84</a></p><p><strong>题目大意：</strong></p><blockquote><p>将整数 n 分成 k 份，且每份不能为空，任意两份不能相同(不考虑顺序)。<br>例如：n = 7，k = 3，下面三种分法被认为是相同的。<br>1，1，5; 1，5，1; 5，1，1;<br>问有多少种不同的分法。</p></blockquote><p><strong>解题思路：</strong></p><p>考虑四种情况：</p><ul><li>至少存在一个 <span class="markdown-them-math-inline">$1$</span> 的情况：总数 <span class="markdown-them-math-inline">$- 1$</span>， 个数 <span class="markdown-them-math-inline">$- 1$</span></li><li>不存在 <span class="markdown-them-math-inline">$1$</span> 的情况：每个数分别 <span class="markdown-them-math-inline">$-1$</span> ，则总数 <span class="markdown-them-math-inline">$-(k*1)$</span> ，个数不变</li><li>当 <span class="markdown-them-math-inline">$n=k$</span> 或 <span class="markdown-them-math-inline">$k=1$</span> 时，只能有 <span class="markdown-them-math-inline">$1$</span> 种划分方法，边界条件，返回 <span class="markdown-them-math-inline">$1$</span></li><li>另外当 <span class="markdown-them-math-inline">$n&lt;k$</span> 时，无法划分，此时返回 <span class="markdown-them-math-inline">$0$</span></li></ul><p><strong>题解：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-keyword">if</span>(n == k || k == <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;     <span class="hljs-keyword">if</span>(n &lt; k)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//至少存在一个1的情况：总数 - 1， 个数 - 1</span>    <span class="hljs-comment">//一定不存在1的情况： k个数均≥2，则每个数都 - 1，总数 - k * 1，个数不变 </span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(n - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">dfs</span>(n - k, k);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n, k;    cin &gt;&gt; n &gt;&gt; k;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">dfs</span>(n, k));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*7 34*/</span></code></pre></div><h2><span id="5-摆动序列dfs实现">5 摆动序列(dfs实现）</span></h2><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T44">http://lx.lanqiao.cn/problem.page?gpid=T44</a></p><p><strong>题目大意：</strong></p><blockquote><p>如果一个序列满足下面的性质，我们就将它称为摆动序列：</p><ul><li><ol><li>序列中的所有数都是不大于k的正整数；</li></ol></li><li><ol start="2"><li>序列中至少有两个数；</li></ol></li><li><ol start="3"><li>序列中的数两两不相等；</li></ol></li><li><ol start="4"><li>如果第 i – 1 个数比第 i – 2 个数大，则第 i 个数比第 i – 2 个数小；如果第 i – 1 个数比第 i – 2 个数小，则第 i 个数比第 i – 2 个数大。</li></ol></li></ul><p>比如，当 k = 3 时，有下面几个这样的序列：</p><div class="highlight"><pre class="code"><code><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">2</span></code></pre></div><p>一共有 8 种，给定 k ，请求出满足上面要求的序列的个数。</p></blockquote><p><strong>解题思路：</strong></p><ul><li>本题用 <span class="markdown-them-math-inline">$dfs$</span> 实现，其中条件 <span class="markdown-them-math-inline">$1$</span> 与条件 <span class="markdown-them-math-inline">$2$</span> 很容易满足。</li><li>条件 <span class="markdown-them-math-inline">$3$</span> 与条件 <span class="markdown-them-math-inline">$4$</span> ，用下列方程即可满足：<div class="markdown-them-math-block">$$    (arr[x - 2] - arr[x - 3]) * (arr[x - 1] - arr[x - 3]) &lt; 0$$</div></li></ul><p><strong>题解：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">30</span>;<span class="hljs-keyword">int</span> arr[maxn], vis[maxn];<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">2</span>)&#123;            ans++;        <span class="hljs-comment">//公式满足条件3与条件4 </span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( (arr[x - <span class="hljs-number">2</span>] - arr[x - <span class="hljs-number">3</span>]) * (arr[x - <span class="hljs-number">1</span>] - arr[x - <span class="hljs-number">3</span>]) &lt; <span class="hljs-number">0</span>)&#123;            ans++;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;            vis[i] = <span class="hljs-number">1</span>;            arr[x] = i;            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>);            vis[i] = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));    cin &gt;&gt; n;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*38*/</span></code></pre></div><h2><span id="6-传球游戏环形dp">6 传球游戏(环形dp)</span></h2><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T97">http://lx.lanqiao.cn/problem.page?gpid=T97</a></p><p><strong>题目大意：</strong></p><blockquote><p>有 <span class="markdown-them-math-inline">$n$</span> 个同学围成一圈，小蛮传了 <span class="markdown-them-math-inline">$m$</span> 次球后，球又回到自己手中，问有多少种传球方法？</p></blockquote><p><strong>解题思路：</strong></p><p>约定，<span class="markdown-them-math-inline">$dp[i][j]$</span> 表示传了 <span class="markdown-them-math-inline">$i$</span> 次球，到第 <span class="markdown-them-math-inline">$j$</span> 个人手上的传球方法。</p><ul><li>因为是环形传球，因此需要考虑两个边界，第 <span class="markdown-them-math-inline">$1$</span> 个人和第 <span class="markdown-them-math-inline">$n$</span> 个人的情况。</li><li>当前同学的传球次数，为左右同学(传了 <span class="markdown-them-math-inline">$i-1$</span> 次球)的传球方法相加<div class="markdown-them-math-block">$$    dp[i][j] = dp[i - 1][x] + dp[i - 1][y]$$</div>其中 <span class="markdown-them-math-inline">$x=j-1,y=j+1$</span></li></ul><p><strong>题解：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">40</span>;<span class="hljs-comment">//dp[i][j]表示传了i次球，到第j个人的次数 </span><span class="hljs-keyword">int</span> dp[maxn][maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-comment">//传了0次球，到第一个人的次数，自然为1 </span>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123;            <span class="hljs-keyword">int</span> x = j - <span class="hljs-number">1</span>, y = j + <span class="hljs-number">1</span>;            <span class="hljs-comment">//考虑第1个人的情况 </span>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>)&#123;                x = n;            &#125;            <span class="hljs-comment">//考虑第n个人的情况</span>            <span class="hljs-keyword">if</span>(j == n)&#123;                y = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">//当前的情况等于左右传了i - 1次球的情况相加 </span>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][x] + dp[i - <span class="hljs-number">1</span>][y];        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[m][<span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*3 32*/</span></code></pre></div><h2><span id="7-方格取数多线程dp">7 方格取数(多线程dp）</span></h2><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T79">http://lx.lanqiao.cn/problem.page?gpid=T79</a></p><p><strong>题目大意：</strong></p><blockquote><p>设有 N * N 的方格图(N &lt;= 10)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。<br>某人从图的左上角的 A 点(1, 1)出发，可以向下行走，也可以向右走，直到到达右下角的 B 点(N, N)。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0 ）。<br>此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。</p></blockquote><p><strong>解题思路：</strong></p><ul><li>可模拟两个人同时从 <span class="markdown-them-math-inline">$(1,1)$</span> 走到 <span class="markdown-them-math-inline">$(N,N)$</span></li><li><span class="markdown-them-math-inline">$dp$</span> 方程：</li></ul><div class="markdown-them-math-block">$$dp[x1][x2][y1][y2] = max(dp[x1 - 1][y1][x2 - 1][y2],$$</div><p><div class="markdown-them-math-block">$$ dp[x1][y1 - 1][x2][y2 - 1], $$</div></p><div class="markdown-them-math-block">$$dp[x1 - 1][y1][x2][y2 - 1], $$</div><div class="markdown-them-math-block">$$dp[x1][y1 - 1][x2 - 1][y2]) $$</div><ul><li>考虑两人走到同一点的特殊情况，只能加一次权值。</li></ul><p><strong>题解：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-comment">/*模拟两个人同时从(1,1)走到(N,N)，转移方程:dp[x1][x2][y1][y2] = max(dp[x1 - 1][y1][x2 - 1][y2],                                  dp[x1][y1 - 1][x2][y2 - 1],                                  dp[x1 - 1][y1][x2][y2 - 1],                                  dp[x1][y1 - 1][x2 - 1][y2]) 考虑两人走到同一点的特殊情况，只能加一次权值。 */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">20</span>;<span class="hljs-keyword">int</span> g[maxn][maxn] = &#123;<span class="hljs-number">0</span>&#125;, dp[maxn][maxn][maxn][maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span>    <span class="hljs-keyword">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        <span class="hljs-keyword">int</span> x, y, value;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; value;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span> &amp;&amp; value == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">break</span>;        &#125;        g[x][y] = value;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x1 = <span class="hljs-number">1</span>;x1 &lt;= n;x1++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y1 = <span class="hljs-number">1</span>;y1 &lt;= n;y1++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x2 = <span class="hljs-number">1</span>;x2 &lt;= n;x2++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y2 = <span class="hljs-number">1</span>;y2 &lt;= n;y2++)&#123;                    <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">max</span>(dp[x1 - <span class="hljs-number">1</span>][y1][x2 - <span class="hljs-number">1</span>][y2], dp[x1][y1 - <span class="hljs-number">1</span>][x2][y2 - <span class="hljs-number">1</span>]);                    temp = <span class="hljs-built_in">max</span>(temp, dp[x1 - <span class="hljs-number">1</span>][y1][x2][y2 - <span class="hljs-number">1</span>]);                    temp = <span class="hljs-built_in">max</span>(temp, dp[x1][y1 - <span class="hljs-number">1</span>][x2 - <span class="hljs-number">1</span>][y2]);                    <span class="hljs-keyword">if</span>(x1 == x2 &amp;&amp; y1 == y2)&#123;                        dp[x1][y1][x2][y2] = temp + g[x1][y1];                    &#125;<span class="hljs-keyword">else</span>&#123;                        dp[x1][y1][x2][y2] = temp + g[x1][y1] + g[x2][y2];                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[n][n][n][n]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*82 3 132 6 63 5 74 4 145 2 215 6 46 3 157 2 140 0 067*/</span></code></pre></div><h2><span id="8-k好数">8 K好数</span></h2><p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T13">http://lx.lanqiao.cn/problem.page?gpid=T13</a></p><p><strong>题目大意：</strong></p><blockquote><p><span class="markdown-them-math-inline">$K$</span> 好数定义：一个自然数 <span class="markdown-them-math-inline">$N$</span> 的 <span class="markdown-them-math-inline">$K$</span>进制表示中任意的相邻的两位都不是相邻的数字。求 <span class="markdown-them-math-inline">$L$</span> 位 <span class="markdown-them-math-inline">$K$</span> 进制数中 <span class="markdown-them-math-inline">$K$</span> 好数的数目。输出它对 <span class="markdown-them-math-inline">$1000000007$</span> 取模后的值。</p></blockquote><p><strong>解题思路：</strong></p><p>我们约定，<span class="markdown-them-math-inline">$dp[i][j]$</span> 表示长度为 <span class="markdown-them-math-inline">$i$</span> ，以 <span class="markdown-them-math-inline">$j$</span> 开头的 <span class="markdown-them-math-inline">$K$</span> 好数个数。</p><ul><li><p><span class="markdown-them-math-inline">$K$</span> 好数中<strong>除开头外</strong>，每位数的取值为：<span class="markdown-them-math-inline">$0 \sim K-1$</span>；</p></li><li><p>以 <span class="markdown-them-math-inline">$K=3，L=3$</span> 为例：<br><div class="markdown-them-math-block">$$ans = dp[3][0]+dp[3][1]+dp[3][2]$$</div><br>其中 <span class="markdown-them-math-inline">$dp[3][0]=dp[2][0]+dp[2][2]$</span><br>   <span class="markdown-them-math-inline">$dp[3][1]=dp[2][1]$</span><br>   <span class="markdown-them-math-inline">$dp[3][2]=dp[2][2]+dp[2][0]$</span></p></li><li><p>以此类推<strong>长度为 <span class="markdown-them-math-inline">$2$</span> ，长度为 <span class="markdown-them-math-inline">$1$</span></strong> 的情况；</p></li><li><p>因此可推出 <span class="markdown-them-math-inline">$dp$</span> 方程：<br><div class="markdown-them-math-block">$$dp[i][j]=dp[i][j]+dp[i-1][x]$$</div><br>其中 <span class="markdown-them-math-inline">$x$</span> 取值为 <span class="markdown-them-math-inline">$0 \sim K-1$</span></p></li><li><p>另外要注意，<span class="markdown-them-math-inline">$K$</span> 好数开头不能为 <span class="markdown-them-math-inline">$0$</span> ；</p></li></ul><p><strong>题解：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">105</span>;<span class="hljs-comment">//dp[i][j]表示长度为i，以j开头的K好数个数 </span><span class="hljs-keyword">int</span> dp[maxn][maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> k, l;    cin &gt;&gt; k &gt;&gt; l;    <span class="hljs-comment">//dp[1][i]表示长度为1，以i开头的K好数个数，此时个数均为 1 </span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//长度由2 → l </span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= l;i++)&#123;        <span class="hljs-comment">//表示以j开头的个数，因为是K进制，所以K的范围为0 ~ K - 1 </span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; k;j++)&#123;            <span class="hljs-comment">//枚举以j为开头时的所有情况 </span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;x &lt; k;x++)&#123;                <span class="hljs-comment">//符号K好数要求的数 </span>                <span class="hljs-keyword">if</span>(x != j + <span class="hljs-number">1</span> &amp;&amp; x != j - <span class="hljs-number">1</span>)&#123;                    <span class="hljs-comment">//dp方程 </span>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][x];                    <span class="hljs-comment">//注意取模 </span>                    dp[i][j] %= MOD;                &#125;            &#125;        &#125;    &#125;     <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-comment">//开头不能为O,所以开头i的范围为1 ~ K - 1 </span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; k;i++)&#123;        ans += dp[l][i];        ans %= MOD;    &#125;     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*4 2 7*/</span></code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-dp%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8&quot;&gt;1 dp基本性质&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="dp" scheme="https://leungll.site/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 算法提高 ADV - 299】宰羊（ 区间 dp ）</title>
    <link href="https://leungll.site/2020/04/08/adv-299/"/>
    <id>https://leungll.site/2020/04/08/adv-299/</id>
    <published>2020-04-08T17:17:45.000Z</published>
    <updated>2024-05-24T07:49:23.416Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：</strong><a href="http://lx.lanqiao.cn/problem.page?gpid=T576">http://lx.lanqiao.cn/problem.page?gpid=T576</a></p><h2><span id="1-题目">1 题目</span></h2><h3><span id="题目描述">题目描述</span></h3><blockquote><p>炫炫回了内蒙，肯定要吃羊肉啦，所有他家要宰羊吃。<br>炫炫家有 N 只羊，羊圈排成一排，标号 1 ~ N。炫炫每天吃掉一只羊（这食量！其实是放生啦），吃掉的羊的邻居会以为它被放生了，然后又会告诉他们的邻居，这样一直传播下去，除非某个邻居已经被“放生”了。每一天，所有知道某羊被“放生”了这个消息的羊都会很不满，如果不给他们巧克力的话，他们就会很造反，炫炫已经知道他要吃掉哪些羊，他可以任意安排吃的顺序，然后使巧克力的用量最小，请求出这个最小值。</p></blockquote><h3><span id="输入格式">输入格式</span></h3><blockquote><p>本题有多组数据，第一行为数据组数 T。<br>对于每组数据：<br>第一行：两个用空格隔开的整数：N 和 M，表示羊的数量和需要吃掉的数量；<br>第二行：有 M 个数，表示要吃那些羊。</p></blockquote><h3><span id="输出格式">输出格式</span></h3><blockquote><p>T 行，为每组数据的答案。</p></blockquote><h3><span id="样例输入">样例输入</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-number">2</span><span class="hljs-symbol">8 </span><span class="hljs-number">1</span><span class="hljs-number">3</span><span class="hljs-symbol">20 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">14</span></code></pre></div><h3><span id="样例输出">样例输出</span></h3><div class="highlight"><pre class="code"><code><span class="hljs-attribute">T</span> = <span class="hljs-number">10</span><span class="hljs-attribute">N</span> &lt;= <span class="hljs-number">10000</span><span class="hljs-attribute">M</span> &lt;= <span class="hljs-number">100</span></code></pre></div><h2><span id="2-分析">2 分析</span></h2><blockquote><p>这题可用 <strong>区间dp</strong> 解决。</p></blockquote><p><strong>1. 首先我们来看（重温）dp的三个性质：</strong></p><ul><li><p><strong>最优子结构</strong></p><ul><li>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的<strong>最优子结构性质</strong>提供了该问题可用动态规划算法求解的重要线索。</li><li>在动态规划算法中，利用问题的最优子结构性质，以<strong>自底向上</strong>的方式递归地从<strong>子问题</strong>的最优解逐步构造出<strong>整个问题的最优解</strong>。</li></ul></li><li><p><strong>重叠子问题</strong></p><ul><li>子问题之间是不独立的，一个子问题在下一阶段决策中可能被<strong>多次使用</strong>。对每个子问题只解一次，而后将其保存在一个表格中，当再次需要的时候，只是简单的用<strong>常数时间</strong>查看一下结果。</li></ul></li><li><p><strong>无后效性</strong></p><ul><li>即某阶段状态一旦确定，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，<strong>只与当前状态有关</strong>。</li></ul></li></ul><p><strong>2. 回到题目中：</strong></p><blockquote><p>首先给出<strong>状态转移方程</strong>：</p><div class="markdown-them-math-block">$$  dp[l][r] = min\{ \, dp[l][r], \,\, dp[l][i - 1] + dp[i + 1][r] + (arr[r + 1] - arr[l - 1] - 2) \, \}$$</div></blockquote><ul><li><p>数组 <span class="markdown-them-math-inline">$arr[i]$</span> 存储被杀羊的<strong>号码</strong>，而 <span class="markdown-them-math-inline">$i$</span> 表示羊在数组 <span class="markdown-them-math-inline">$arr$</span> 中的<strong>编号</strong>，例如在第2个样例中，一共有3只羊被杀，羊的号码分别为<span class="markdown-them-math-inline">$3,6,14$</span> ，则数组存储的规则为：<span class="markdown-them-math-inline">$arr[1]=3,arr[2]=6,arr[3]=14$</span>。</p></li><li><p><span class="markdown-them-math-inline">$dp[l][r]$</span> 表示杀掉 <span class="markdown-them-math-inline">$arr[l] \sim arr[r]$</span> 只羊所花费的<strong>最小代价</strong>。这个表达可能有些拗口，举个栗子：<span class="markdown-them-math-inline">$dp[1][3]$</span> 表示杀掉<strong>数组编号</strong>为 <span class="markdown-them-math-inline">$1,2,3$</span> 的羊花费的最小代价，即 <span class="markdown-them-math-inline">$arr[1],arr[2],arr[3]$</span> 这三只羊。</p></li></ul><p><strong>3. 为什么要用 dp 求解：</strong></p><p>再来看一下题意，题目有两点关键信息：</p><ul><li>羊圈<strong>排成一排</strong>，标号为 <span class="markdown-them-math-inline">$1\sim N$</span>。（也就是说，羊圈的<strong>羊头和羊尾</strong>不会再传播下去）</li><li>炫炫每吃掉一只羊，这只羊的邻居就会引起恐慌，接着这只羊的邻居们会继续告诉他们的邻居，一直传播下去，什么时候传播恐慌结束？（划重点！），<strong>当某个邻居已经被杀掉时</strong>。</li></ul><p>我们可以看出，其实求 <span class="markdown-them-math-inline">$dp[l][r]$</span> 可以缩小问题规模，变成求 <span class="markdown-them-math-inline">$dp[l][k] + dp[k + 1][r]$</span> 的最小代价，对吧？如果你认为没问题，好，通过不断地拆分区间求解，问题的规模得到了缩小，这里符合dp基本性质之一“<strong>最优子结构</strong>”。</p><p>而我们知道，在动态规划算法中，利用问题的最优子结构性质，是以<strong>自底向上</strong>的方式递归地从<strong>子问题</strong>的最优解逐步构造出<strong>整个问题的最优解</strong>。</p><p>在本题中，从<strong>子问题 → 整个问题</strong>的求解，可以这样做，区间以<strong>每只即将被杀掉的羊为结点</strong>划分：</p><ul><li>按照区间长度<strong>由小到大</strong>的规则，计算最小代价，即我们先从长度为 <span class="markdown-them-math-inline">$1$</span> 的区间开始计算最小代价，再计算区间长度为 <span class="markdown-them-math-inline">$2→3→4→5→…$</span> 的最小代价。最后当区间长度为 <span class="markdown-them-math-inline">$m$</span> 时，就是问题的<strong>求解结果</strong>。</li><li>当区间长度 ＞ 1时，这时需要<strong>逐个遍历</strong>区间中每只即将被杀掉的 <span class="markdown-them-math-inline">$arr[i]$</span> 羊，通过 dp 方程去计算最小代价。</li></ul><p>在本题中，从区间的角度，我们要求的最小代价 <span class="markdown-them-math-inline">$dp[1][m]$</span> ，可以表示成：</p><div class="markdown-them-math-block">$$    dp[1][m] = dp[1] [k - 1] + arr[k] + dp[k + 1] [m]$$</div><p>即杀掉所有羊的代价可以变成求杀掉 <span class="markdown-them-math-inline">$arr[1] \sim arr[k - 1]$</span> 只羊的最小代价与 <span class="markdown-them-math-inline">$arr[k + 1] \sim arr[m]$</span> 只羊，再加上杀掉 <span class="markdown-them-math-inline">$arr[k]$</span> 的最小代价。</p><p>好了，到这一步应该没有太难理解的地方，那么应该如何求杀掉 <span class="markdown-them-math-inline">$arr[k]$</span> 的最小代价？</p><p><strong>4. 如何求杀掉 <span class="markdown-them-math-inline">$arr[k]$</span> 的最小代价：</strong>：</p><blockquote><p>通过上面列出的 dp 方程中可以看到</p><div class="markdown-them-math-block">$$  arr[k]=arr[r + 1] - arr[l - 1] - 2$$</div></blockquote><p>为啥？</p><p>我们改一下第 1 个样例中的数据，再举个栗子：</p><blockquote><p>羊   圈：1 <strong><code>2</code></strong> <strong><code>3</code></strong> 4 <strong><code>5</code></strong> 6 7 8<br>待杀羊号码：2 3 5  <span class="markdown-them-math-inline">$（arr[1]=2, arr[2]=3, arr[3]=5）$</span><br>考虑区间：{ <span class="markdown-them-math-inline">$2$</span> }，<span class="markdown-them-math-inline">$2$</span> 表示待杀羊在数组中的<strong>编号</strong>。</p></blockquote><p>即我们要杀掉号码为 <span class="markdown-them-math-inline">$3$</span>（<span class="markdown-them-math-inline">$arr[2]=3$</span>）的这只羊，也就是要求杀掉 <span class="markdown-them-math-inline">$arr[2]$</span> 的代价，这时候3号羊的邻居得到了消息，它们开始传播消息，什么时候传播停止？<strong>遇到了号码为2与号码为5的羊</strong>！</p><p>换句话说，我们在杀死号码为3的这只羊时，它的左右邻居肯定被影响，也就是区间外的羊也会被影响，而<strong>传播停止是在遇到被杀死的羊的时候。</strong></p><p>再来看公式：</p><div class="markdown-them-math-block">$$    arr[k]=arr[r + 1] - arr[l - 1] - 2$$</div><p>是将区间扩展到<strong>左右边界外第一只</strong>待杀死的羊，为啥是 <span class="markdown-them-math-inline">$－2$</span> ？</p><ul><li>公式中已经将区间扩展到了 <span class="markdown-them-math-inline">$arr[r + 1]与arr[l - 1]$</span> ，即{ <strong><code>2</code>, <code>3</code>, 4, <code>5</code></strong> }，就是例子中羊的号码为 <span class="markdown-them-math-inline">$2$</span> 与号码为 <span class="markdown-them-math-inline">$5$</span> 的位置，这两只羊是要被杀死的，此时区间中有 <span class="markdown-them-math-inline">$5-2-1$</span> 只羊。</li><li>而号码 <span class="markdown-them-math-inline">$3$</span>（即<span class="markdown-them-math-inline">$arr[2]$</span>）是我们最开始要杀的羊，所以最小代价为 <span class="markdown-them-math-inline">$5 - 2 - 1 - 1$</span>，即<span class="markdown-them-math-inline">$5 - 2 - 2 = 1$</span>，我们需要给一块巧克力去安慰号码为 <span class="markdown-them-math-inline">$4$</span> 这只羊。</li></ul><p>接下来<strong>验证</strong>一下这个公式是否合理：</p><ul><li><p>考虑区间：{ <span class="markdown-them-math-inline">$2$</span> }，此时区间长度为 <span class="markdown-them-math-inline">$1$</span>，区间左部 <span class="markdown-them-math-inline">$l$</span> 与区间右部 <span class="markdown-them-math-inline">$r$</span> 相等，所以 <span class="markdown-them-math-inline">$l=r=2$</span>（前面约定，区间是以<strong>每只即将被杀掉的羊为结点</strong>划分，在这个例子中，羊的结点编号为 <span class="markdown-them-math-inline">$2$</span> ）</p></li><li><p>代入公式：</p><div class="markdown-them-math-block">$$    arr[2]=arr[2 + 1] - arr[2 - 1] - 2=1$$</div></li><li><p>公式结果表明，杀掉 <span class="markdown-them-math-inline">$arr[2]$</span> 这只羊，最小代价是 <span class="markdown-them-math-inline">$1$</span>。</p></li></ul><p><strong>5. 考虑边界值：</strong></p><ul><li>题意说到，羊圈是排成一排的，即羊首与羊尾不会再传播给它的邻居，因此为了处理方便，我们设 <span class="markdown-them-math-inline">$arr[0] = 0，arr[m + 1] = n + 1$</span> 。</li><li>当区间长度为1时，此时区间里只有一只待杀的羊，这时不需要再进行区间划分，直接计算杀掉 <span class="markdown-them-math-inline">$arr[k]$</span> 的代价即可。即：<br><div class="markdown-them-math-block">$$dp[l][r] = arr[r + 1] - arr[l - 1] - 2$$</div></li></ul><h2><span id="3-题解">3 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f</span>;<span class="hljs-keyword">int</span> arr[maxn] = &#123;<span class="hljs-number">0</span>&#125;, dp[maxn][maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);</span>    <span class="hljs-keyword">int</span> t;    cin &gt;&gt; t;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;x &lt; t;x++)&#123;        <span class="hljs-keyword">int</span> n, m;        cin &gt;&gt; n &gt;&gt; m;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)&#123;            cin &gt;&gt; arr[i];        &#125;        <span class="hljs-comment">//处理边界值 </span>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, arr[m + <span class="hljs-number">1</span>] = n + <span class="hljs-number">1</span>;        <span class="hljs-comment">//区间长度由小到大 </span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;len &lt;= m;len++)&#123;            <span class="hljs-comment">//考虑区间情况 l → r </span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>;l + len &lt;= m + <span class="hljs-number">1</span>;l++)&#123;                <span class="hljs-comment">//计算区间的右边界 r</span>                <span class="hljs-keyword">int</span> r = l + len - <span class="hljs-number">1</span>;                <span class="hljs-comment">//区间长度为 1 的特殊情况 </span>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;                    dp[l][r] = arr[r + <span class="hljs-number">1</span>] - arr[l - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-comment">//赋初值 </span>                    dp[l][r] = INF;                    <span class="hljs-comment">//逐个遍历区间内每只待杀的羊 </span>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l;i &lt;= r;i++)&#123;                        dp[l][r] = <span class="hljs-built_in">min</span>( dp[l][r], dp[l][i - <span class="hljs-number">1</span>] + dp[i + <span class="hljs-number">1</span>][r] + arr[r + <span class="hljs-number">1</span>] - arr[l - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> );                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dp[<span class="hljs-number">1</span>][m]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>如果你还是有一些疑惑，建议在代码中进行调试，输出各数据的运行情况，这可能有利于你理解。<br>另外如果你想进一步了解<strong>区间 dp 原理</strong>，可以查看 <span class="markdown-them-math-inline">$References$</span> 链接中的第一个。</p><h2><span id="4-references">4 References</span></h2><ul><li><a href="https://blog.csdn.net/qq_40772692/article/details/80183248">https://blog.csdn.net/qq_40772692/article/details/80183248</a></li><li><a href="https://www.acwing.com/community/content/49891/">https://www.acwing.com/community/content/49891/</a></li></ul><p>有问题欢迎指正！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;a href=&quot;http://lx.lanqiao.cn/problem.page?gpid=T576&quot;&gt;http://lx.lanqiao.cn/problem.page?gpid=T576&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="dp" scheme="https://leungll.site/tags/dp/"/>
    
    <category term="蓝桥杯" scheme="https://leungll.site/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="区间dp" scheme="https://leungll.site/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>站点（e.g. Hexo Blog）提交百度搜索引擎收录实现SEO</title>
    <link href="https://leungll.site/2020/04/06/hexo-blog-seo/"/>
    <id>https://leungll.site/2020/04/06/hexo-blog-seo/</id>
    <published>2020-04-06T11:38:33.000Z</published>
    <updated>2025-01-05T07:08:03.322Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#1-%E7%AB%99%E7%82%B9url%E4%BC%98%E5%8C%96">1 站点URL优化</a></li><li><a href="#2-%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%AB%99%E6%98%AF%E5%90%A6%E8%A2%AB%E6%94%B6%E5%BD%95">2 查看网站是否被收录</a></li><li><a href="#3-%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E8%87%B3%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E8%B5%84%E6%BA%90%E5%B9%B3%E5%8F%B0">3 添加站点至百度搜索资源平台</a><ul><li><a href="#31-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%A4%E8%AF%81%E7%AB%99%E7%82%B9">3.1 为什么要认证站点</a></li><li><a href="#32-%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%AB%99%E7%82%B9">3.2 如何验证站点</a></li><li><a href="#33-%E5%85%B3%E4%BA%8E%E8%AE%A4%E8%AF%81http%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AF%B4%E6%98%8E">3.3 关于认证HTTP协议的说明</a></li></ul></li><li><a href="#4-%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2">4 提交百度搜索</a><ul><li><a href="#41-%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D">4.1 提交方式介绍</a></li><li><a href="#42-%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81">4.2 主动推送</a></li><li><a href="#43-%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81">4.3 自动推送</a></li><li><a href="#44-sitemap%E6%8F%90%E4%BA%A4">4.4 sitemap提交</a></li><li><a href="#45-%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4">4.5 手动提交</a></li></ul></li><li><a href="#5-%E6%8E%A8%E9%80%81%E6%95%88%E6%9E%9C">5 推送效果</a></li><li><a href="#6-%E6%94%B6%E5%BD%95%E7%BB%93%E6%9E%9C%E6%9F%A5%E8%AF%A2">6 收录结果查询</a></li><li><a href="#7-references">7 References</a></li></ul><!-- tocstop --><h2><span id="前言">前言</span></h2><blockquote><p>SEO 指的是搜索引擎优化。通过搜索引擎优化，可以提高网站的网站关键词排名以及博客文章的曝光度。<br>个人的网站搭建好之后，百度谷歌等搜索引擎其实是收录不到我们网站内容的，并且托管在 Github 上的站点甚至进行了反爬虫处理，搜索引擎的小蜘蛛更加爬不到你的 Blog 了。<br>因此我们要做的是<strong>提交搜索引擎收录</strong>，使得搜索引擎收录我们的网站。考虑到我们在国内，因此本文只讲解如何实现百度搜索引擎收录，Google 的原理其实和百度的类似。</p></blockquote><h2><span id="1-站点url优化">1 站点URL优化</span></h2><blockquote><p>一个好的 URL 设计，不仅有利于网络爬虫的爬取，更有利于用户的体验。</p></blockquote><p>正确的 URL 设计应该满足：</p><ul><li>长度尽量短；</li><li>目录层次尽量少；</li><li>全小写，连字符使用中划线 <code>-</code>；</li><li>具有描述性，包含关键词等；</li></ul><p>如果你的站点是使用 Hexo 框架搭建的，那么我建议你安装下面其中一款插件实现 URL 优化（排名具有先后顺序）：</p><ul><li><a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a>；</li><li>设计 urlname ；</li><li>中文链接转拼音方式( <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> 插件 ）；</li></ul><h2><span id="2-查看网站是否被收录">2 查看网站是否被收录</span></h2><p>在搜索引擎中输入 <code>site:域名</code> ，查看站点是否被收录，可以看到站点没有被收录：</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-01.png" alt="hexo-blog-seo-01"></p><h2><span id="3-添加站点至百度搜索资源平台">3 添加站点至百度搜索资源平台</span></h2><h3><span id="31-为什么要认证站点">3.1 为什么要认证站点</span></h3><blockquote><p>站长平台推荐站长添加主站（您网站的链接也许会使用 www 和非 www 两种网址，建议添加用户能够真实访问到的网址），添加并验证后，可证明您是该域名的拥有者，可以快捷批量添加子站点，查看所有子站数据，无需再一一验证您的子站点。</p></blockquote><h3><span id="32-如何验证站点">3.2 如何验证站点</span></h3><blockquote><p>关于选择验证站点选择的协议上，有两点要说明：</p><ul><li><strong>如果你的站点购买了域名：</strong> 建议你先将站点实现<strong>全站 HTTPS <strong>，再在百度站长平台中选择</strong> HTTPS 协议</strong>认证。如若 HTTPS 认证始终没能通过，再选择认证 HTTP 协议。</li><li><strong>如果你的站点是部署在 Github/Gitee 并没有购买域名：</strong> 因为 Github/Gitee 实现了<strong>强制 HTTPS 协议</strong>，你可能必须要在百度站长平台中选择 <strong>HTTPS 协议</strong>认证。如果选择的是 <strong>HTTP 协议</strong>认证，会出现<strong>验证失败</strong>的情况，并提示你将 http 的 url 301 到 https 的 url。关于这一点，我会在后面说明。</li></ul></blockquote><p>下文将以选择 <strong>HTTP 协议</strong>认证为例：</p><p><strong>1. 进入官网：</strong><a href="https://ziyuan.baidu.com/">百度搜索资源平台官网</a></p><p><strong>2. 点击“用户中心” → “站点管理”：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-02.png" alt="hexo-blog-seo-02"></p><p><strong>3. 输入域名网址：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-03.png" alt="hexo-blog-seo-03"></p><p><strong>4. 设置站点领域：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-04.png" alt="hexo-blog-seo-04"></p><p><strong>5. 选择验证方式：</strong></p><ul><li><strong>文件验证</strong>：下载给定的文件，将其放到本地主题目录 source 文件夹，然后部署博客完成验证</li><li><strong>HTML 标签验证</strong>：给一个<code>meta</code>标签，放到首页<code>&lt;head&gt;</code>与 <code>&lt;/head&gt; </code>标签之间即可完成验证</li><li><strong>CNAME 验证</strong>：需要登录域名提供商或托管服务提供商的网站，添加新的 DNS 记录。如果你购买了域名，这种方式最简单，只需去域名 DNS 添加一个<code>CNAME</code>记录即可完成验证</li></ul><p>刚开始我选择的是<strong>文件验证</strong>方式，但一直提示验证文件内容不符，因此选择了 <strong>HTML 标签验证</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-06.png" alt="hexo-blog-seo-06"></p><p>将标签放在 Hexo 文件主题目录下<code>\themes\Chic\layout\_partial</code>的<code>head.ejs</code>的<code>&lt;head&gt;</code>与 <code>&lt;/head&gt; </code>标签之间（文件路径供参考）</p><div class="highlight"><pre class="code"><code>&lt;meta name=&quot;baidu-site-verification&quot; <span class="hljs-attribute">content</span>=&quot;XXXXXXXXXX&quot; /&gt;</code></pre></div><p><strong>6. 点击完成验证，并等待审核：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-07.png" alt="hexo-blog-seo-07"></p><p>几小时过后，站长平台会提示你审核结果：</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-08.png" alt="hexo-blog-seo-08"></p><h3><span id="33-关于认证http协议的说明">3.3 关于认证HTTP协议的说明</span></h3><blockquote><p>以我的站点为例，站点是双线部署在 <strong>Github/Gitee</strong> 上的，并没有购买域名。即我的域名还是原始域名：<strong><a href="https://yourname.github.io">https://yourname.github.io</a> &amp;&amp; <a href="https://yourname.gitee.io">https://yourname.gitee.io</a></strong>，可以看到 Github 与 Gitee 都已经将你的网站强制部署在 https 安全域名下。</p></blockquote><p>因此当我在百度站长平台中选择认证 <strong>HTTP 协议</strong>时：</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-09.png" alt="hexo-blog-seo-09"></p><p><strong>我的验证是失败的：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-10.png" alt="hexo-blog-seo-10"></p><p><strong>并提示你将 http 的 url 301 到 https 的 url：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-11.png" alt="hexo-blog-seo-11"></p><p>关于 301，大多数玩 SEO 的朋友都了解，在这里不多说，贴下百度站长平台的解释：</p><blockquote><ul><li>HTTPS 协议的站点信息更加安全，同时可降低网站被劫持的风险，如网站同时存在 HTTP 和 HTTPS 站点，可使用本工具进行认证，便于百度搜索识别网站。HTTP 与 HTTPS 之间的对应关系，识别成功后，搜索端将及时展示网站 HTTPS 资源；</li><li>使用 HTTPS 认证，需要保证全站所有链接都支持 HTTPS 访问；</li><li>每个站点每天最多可使用 3 次认证功能；</li></ul></blockquote><h2><span id="4-提交百度搜索">4 提交百度搜索</span></h2><blockquote><p>进入链接：<strong>资源提交 → 链接提交</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-12.png" alt="hexo-blog-seo-12"></p><h3><span id="41-提交方式介绍">4.1 提交方式介绍</span></h3><p>百度提供了<strong>自动提交</strong>和<strong>手动提交</strong>两种方式，其中自动提交又分为<strong>主动推送</strong>、<strong>自动推送</strong>和 <strong>sitemap</strong> 三种方式，以下是官网给出的解释：</p><ul><li><p><strong>主动推送</strong>：最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</p></li><li><p><strong>自动推送</strong>：是轻量级链接提交组件，将自动推送的JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现。</p></li><li><p><strong>sitemap</strong>：您可以定期将网站链接放到 Sitemap 中，然后将 Sitemap 提交给百度。百度会周期性的抓取检查您提交的 Sitemap ，对其中的链接进行处理，但收录速度慢于主动推送。</p></li><li><p><strong>手工提交</strong>：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度。</p></li></ul><table><thead><tr><th>方式</th><th>主动推送</th><th>自动推送</th><th>sitemap</th><th>手工提交</th></tr></thead><tbody><tr><td>速度</td><td>最快</td><td>——</td><td>——</td><td>——</td></tr><tr><td>开发成本</td><td>高</td><td>低</td><td>中</td><td>不需开发</td></tr><tr><td>可提交量</td><td>低</td><td>高</td><td>高</td><td>低</td></tr><tr><td>是否建议提交历史连接</td><td>否</td><td>是</td><td>是</td><td>是</td></tr><tr><td>和其他提交方法是否有冲突</td><td>无</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><blockquote><p>从效率来说，<strong>主动推送 &gt; 自动推送 &gt; sitemap</strong></p></blockquote><h3><span id="42-主动推送">4.2 主动推送</span></h3><p><strong>1. 使用主动推送功能会达到怎样效果：</strong></p><ul><li><strong>及时发现</strong>：可以缩短百度爬虫发现您站点新链接的时间，使新发布的页面可以在第一时间被百度收录</li><li><strong>保护原创</strong>：对于网站的最新原创内容，使用主动推送功能可以快速通知到百度，使内容可以在转发之前被百度发现</li></ul><p><strong>2. 在博客根目录安装插件 ：</strong></p><div class="highlight"><pre class="code"><code>npm install hexo-baidu-url-submit --save</code></pre></div><p>然后在根目录 <code>_config.yml</code> 文件里写入以下配置：</p><div class="highlight"><pre class="code"><code><span class="hljs-attr">baidu_url_submit:</span>  <span class="hljs-attr">count:</span> <span class="hljs-number">10</span>                           <span class="hljs-comment"># 提交最新的多少个链接</span>  <span class="hljs-attr">host:</span> <span class="hljs-string">https://yourname.gitee.io/</span>    <span class="hljs-comment"># 在百度站长平台中添加的域名</span>  <span class="hljs-attr">token:</span> <span class="hljs-string">your_token</span>                   <span class="hljs-comment"># 秘钥</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">baidu_urls.txt</span>                <span class="hljs-comment"># 文本文档的地址,新链接会保存在此文本文档里</span></code></pre></div><ul><li><p>记得查看 Hexo 根目录<code>_config.yml</code>文件中<code>url</code>的值，必须包含是百度站长平台注册的域名， 比如:</p><div class="highlight"><pre class="code"><code><span class="hljs-comment"># URL</span><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourname.gitee.io/</span><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:urlname/</span></code></pre></div></li><li><p><code>token</code> 可以在<strong>链接提交</strong>  →  <strong>自动提交</strong>  →  <strong>主动推送</strong>下面看到，接口调用地址最后面 <code>token=xxxxx</code> 即为你的 <code>token</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-13.png" alt="hexo-blog-seo-13"></p></li></ul><p><strong>3. 在根目录 <code>_config.yml</code> 修改 <code>deployer</code>：</strong></p><div class="highlight"><pre class="code"><code><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><span class="hljs-attr">deploy:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span> <span class="hljs-comment">## 这是原来的deployer</span>  <span class="hljs-attr">repo:</span>  <span class="hljs-attr">branch:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">baidu_url_submitter</span> <span class="hljs-comment">## 在这里添加新内容即可</span></code></pre></div><p><strong>4. 最后执行 <code>hexo g -d</code> 部署一遍即可实现主动推送，推送成功的标志是：在执行部署命令</strong>最后<strong>会显示类似如下代码</strong></p><div class="highlight"><pre class="code"><code>&#123;<span class="hljs-string">&quot;remain&quot;</span>:2992,<span class="hljs-string">&quot;success&quot;</span>:7&#125;INFO  Deploy <span class="hljs-keyword">done</span>:  baidu_url_submitter</code></pre></div><p><strong>5. 查看推送反馈：</strong></p><ul><li>你可以通过推送后返回的状态码和字段来判断数据是否推送成功。</li><li>状态码为 200 ，表示推送成功，可能返回以下字段：</li></ul><table><thead><tr><th>字段</th><th>是否必选</th><th>参数类型</th><th>说明</th></tr></thead><tbody><tr><td>success</td><td>是</td><td>int</td><td>成功推送的url条数</td></tr><tr><td>remain</td><td>是</td><td>int</td><td>当天剩余的可推送url条数</td></tr><tr><td>not_same_site</td><td>否</td><td>array</td><td>由于不是本站url而未处理的url列表</td></tr><tr><td>not_valid</td><td>否</td><td>array</td><td>不合法的url列表</td></tr></tbody></table><ul><li>成功返回示例：<div class="highlight"><pre class="code"><code>&#123;   <span class="hljs-string">&quot;remain&quot;</span>:4999998,   <span class="hljs-string">&quot;success&quot;</span>:2,   <span class="hljs-string">&quot;not_same_site&quot;</span>:[],   <span class="hljs-string">&quot;not_valid&quot;</span>:[]&#125;</code></pre></div></li></ul><p><strong>6. 同时在<code>hexo\.deploy_git\</code>路径下会生成一个<code>baidu_urls.txt</code>文件，其中包含了你站点中的 URL 链接：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-14.png" alt="hexo-blog-seo-14"></p><h3><span id="43-自动推送">4.3 自动推送</span></h3><blockquote><p>自动推送是百度搜索资源平台为提高站点新增网页发现速度推出的工具，安装自动推送 JS 代码的网页，在<strong>页面被访问</strong>时，页面 URL 将立即被推送给百度。</p></blockquote><p><strong>1. 服务对象及原理：</strong></p><ul><li>JS 链接推送代码以网页为最小对象，服务于全平台多终端，PC 站和移动站均可使用。<br>安装代码的页面在任意平台（浏览器、微信、微博）被加载时，页面链接会被第一时间推送给百度，从而提高站点新内容的发现速度。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-15.png" alt="hexo-blog-seo-15"></p><p><strong>2. 操作</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-16.png" alt="hexo-blog-seo-16"></p><ul><li><p>有些 hexo 主题集成了这项功能，比如 Next 主题，在<code>themes\next\layout_scripts\</code>下有个 <code>baidu_push.swig</code> 文件，只需要把代码粘贴到该文件，然后在主题配置文件设置 <code>baidu_push: true</code> 即可。</p></li><li><p>对于大部分 Hexo 主题是没有集成这项功能的，我们可以把代码粘贴到 <code>header.ejs</code> 文件的 <code>&lt;head&gt;</code> 与 <code>&lt;/head&gt;</code> 标签之间即可，从而实现自动推送。</p></li><li><p>代码：</p><div class="highlight"><pre class="code"><code>&lt;script&gt;(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> bp = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);    <span class="hljs-keyword">var</span> curProtocol = <span class="hljs-built_in">window</span>.location.protocol.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (curProtocol === <span class="hljs-string">&#x27;https&#x27;</span>) &#123;        bp.src = <span class="hljs-string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span>;    &#125;    <span class="hljs-keyword">else</span> &#123;        bp.src = <span class="hljs-string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;    &#125;    <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;script&quot;</span>)[<span class="hljs-number">0</span>];    s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;</code></pre></div></li></ul><ul><li>再重新部署即可。</li></ul><h3><span id="44-sitemap提交">4.4 sitemap提交</span></h3><ul><li><p>生成一个网站地图：</p><div class="highlight"><pre class="code"><code>npm install hexo-generator-baidu-sitemap --save</code></pre></div></li><li><p>记得查看 Hexo 根目录<code>_config.yml</code>文件中<code>url</code>的值，必须包含是百度站长平台注册的域名， 比如:</p><div class="highlight"><pre class="code"><code><span class="hljs-comment"># URL</span><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourname.gitee.io/</span><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:urlname/</span></code></pre></div></li><li><p>使用命令 <code>hexo g -d</code> 将网站部署上去，然后访问 <code>你的域名/baidusitemap.xml</code> 就可以看到网站地图</p></li><li><p>来到百度站长平台的 <code>sitemap</code> 提交页面，将你的 <code>sitemap 地址</code>提交即可。如果以后你博客有新的文章或其他页面，可以点击手动更新文件，更新一下新的 <code>sitemap</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-17.png" alt="hexo-blog-seo-17"></p></li></ul><h3><span id="45-手动提交">4.5 手动提交</span></h3><blockquote><p>手动提交不需要其他额外操作，直接把需要收录的页面的 url 提交即可，这种方法效率较低，更新较慢，不推荐使用。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-18.png" alt="hexo-blog-seo-18"></p><h2><span id="5-推送效果">5 推送效果</span></h2><ul><li>链接提交以后，大概<strong>两天</strong>左右，在站长平台中会有显示：</li></ul><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-19.png" alt="hexo-blog-seo-19"></th><th><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-20.png" alt="hexo-blog-seo-20"></th></tr></thead></table><ul><li>sitemap 抓取结果（大概<strong>20天</strong>过后）：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-21.png" alt="hexo-blog-seo-21"></p><h2><span id="6-收录结果查询">6 收录结果查询</span></h2><p>输入 <code>site: 域名</code> ，查询：</p><p><img src="https://cdn.jsdelivr.net/gh/leungll/MyImgHosting/img/hexo-blog-seo-22.png" alt="hexo-blog-seo-22"></p><h2><span id="7-references">7 References</span></h2><ul><li><p><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1#02">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=1#02</a></p></li><li><p><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title18">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title18</a></p></li><li><p><a href="https://www.itrhx.com/2019/09/17/A48-submit-search-engine-inclusion/">https://www.itrhx.com/2019/09/17/A48-submit-search-engine-inclusion/</a></p></li></ul><p>好了，接下来就可以愉快玩耍了，欢迎留言讨论！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%89%8D%E8%A8%80&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E7%AB%99%E7%82%B9url%E4%BC%98%E5%8C%96&quot;&gt;1 站点URL优化&lt;/a&gt;&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Hexo" scheme="https://leungll.site/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://leungll.site/tags/Hexo/"/>
    
    <category term="SEO" scheme="https://leungll.site/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>【蓝桥杯 算法训练 ALGO - 28】星际交流</title>
    <link href="https://leungll.site/2020/04/05/algo-28/"/>
    <id>https://leungll.site/2020/04/05/algo-28/</id>
    <published>2020-04-05T15:13:33.000Z</published>
    <updated>2024-05-03T14:14:11.938Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="1-题目">1 题目</span></h2><h3><span id="题目描述">题目描述</span></h3><blockquote><p>人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。<br>火星人用一种非常简单的方式来表示数字：掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 1，2，3 ……。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。<br>一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指：拇指、食指、中指、无名指和小指分别编号为 1，2，3，4 和 5 ，当它们按正常顺序排列时，形成了 5 位数 12345 ，当你交换无名指和小指的位置时，会形成 5 位数 12354 ，当你把五个手指的顺序完全颠倒时，会形成 54321 ，在所有能够形成的 120 个 5 位数中，12345 最小，它表示 1 ；12354 第二小，它表示 2 ；54321 最大，它表示 120 。下表展示了只有 3 根手指时能够形成的 6 个 3 位数和它们代表的数字：<br>三进制数：</p><div class="highlight"><pre class="code"><code>　　123　　132　　213　　231　　312　　321</code></pre></div><p>代表的数字：</p><div class="highlight"><pre class="code"><code>　　1　　2　　3　　4　　5　　6</code></pre></div><p>现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。</p></blockquote><h3><span id="输入格式">输入格式</span></h3><blockquote><p>包括三行，第一行有一个正整数 N ，表示火星人手指的数目（1 &lt;= N &lt;= 10000）。第二行是一个正整数M，表示要加上去的小整数（1 &lt;= M &lt;= 100）。下一行是 1 到 N 这 N 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。</p></blockquote><h3><span id="输出格式">输出格式</span></h3><blockquote><p>只有一行，这一行含有 N 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。</p></blockquote><h3><span id="样例输入">样例输入</span></h3><blockquote><p>5<br>3<br>1 2 3 4 5</p></blockquote><h3><span id="样例输出">样例输出</span></h3><blockquote><p>1 2 4 5 3</p></blockquote><h3><span id="数据规模和约定">数据规模和约定</span></h3><blockquote><p>对于 30% 的数据，N &lt;= 15；<br>对于 60% 的数据，N &lt;= 50；<br>对于全部的数据，N &lt;= 10000；</p></blockquote><h2><span id="2-分析">2 分析</span></h2><ul><li>此题如果熟悉 C++ STL 库<code>next_permutation()</code>的函数，就是一道 checkin 题。</li><li>刚开始想到了列出排列数，并逐一存储再处理，网上也有人给出了回溯的解法。</li><li><strong>注意</strong>：如果你是 Devc++ 的“死忠粉”（这年头谁想主动用这玩意啊），请一定要熟悉 <strong>permutation</strong> 的拼写…</li><li><code>next_permutation()</code>所在库文件：<code>#include &lt;algorithm&gt;</code>。</li></ul><h2><span id="3-题解">3 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">int</span> arr[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n, m;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        cin &gt;&gt; arr[i];    &#125;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(arr, arr + n) &amp;&amp; ++cnt &lt; m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;1-题目&quot;&gt;1 题目&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span id=&quot;题目描述&quot;&gt;题目描述&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="蓝桥杯" scheme="https://leungll.site/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="排列生成算法" scheme="https://leungll.site/tags/%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【PAT甲级】1002 A+B for Polynomials</title>
    <link href="https://leungll.site/2020/04/05/pat-1002/"/>
    <id>https://leungll.site/2020/04/05/pat-1002/</id>
    <published>2020-04-05T14:39:26.000Z</published>
    <updated>2024-04-29T11:50:40.396Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接</strong>：<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000">1002 A+B for Polynomials</a></p><h2><span id="1-题目">1 题目</span></h2><blockquote><p>This time, you are supposed to find A+B where A and B are two polynomials.</p></blockquote><h3><span id="input-specification">Input Specification</span></h3><blockquote><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:<br><span class="markdown-them-math-inline">$K\ N_1\ a_{​N​1}​​​​ N_2\ a_{​N​2}​​​​...\ N_K​\ a_{​N​K}​​​​$</span><br>where <span class="markdown-them-math-inline">$K$</span> is the number of nonzero terms in the polynomial, <span class="markdown-them-math-inline">$N​_i$</span>​​ and <span class="markdown-them-math-inline">$a​_{N​i}​​​​(i=1,2,⋯,K)$</span> are the exponents and coefficients, respectively. It is given that<br><span class="markdown-them-math-inline">$1 ≤ K ≤ 10，0 ≤ N​_K​ ​&lt; ⋯ &lt; N_2 ​​&lt; N​_1 ≤ 1000$</span>.</p></blockquote><h3><span id="output-specification">Output Specification</span></h3><blockquote><p>For each test case you should output the sum of <span class="markdown-them-math-inline">$A$</span> and <span class="markdown-them-math-inline">$B$</span> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p></blockquote><h3><span id="sample-input">Sample Input</span></h3><blockquote><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p></blockquote><h3><span id="sample-output">Sample Output</span></h3><blockquote><p>3 2 1.5 1 2.9 0 3.2</p></blockquote><h2><span id="2-分析">2 分析</span></h2><p>这道题有几个点需要注意：</p><ul><li>处理<strong>输入数据方式</strong>和常规有一些区别</li><li>coefficients 为<strong>浮点数</strong>且为<strong>负数时也要输出</strong></li><li>输出要精确到<strong>小数点后一位</strong></li><li>最后<strong>没有空格</strong></li></ul><h2><span id="3-题解">3 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> a[maxn] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ONLINE_JUDGE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// ONLINE_JUDGE</span></span>    <span class="hljs-keyword">int</span> k;    cin &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        <span class="hljs-keyword">int</span> exp;        <span class="hljs-keyword">double</span> coe;        cin &gt;&gt; exp &gt;&gt; coe;        a[exp] = coe;    &#125;    cin &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        <span class="hljs-keyword">int</span> exp;        <span class="hljs-keyword">double</span> coe;        cin &gt;&gt; exp &gt;&gt; coe;        a[exp] += coe;    &#125;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; maxn;i++)&#123;        <span class="hljs-keyword">if</span>(a[i])&#123;            cnt++;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = maxn;i &gt;= <span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-comment">//负数也需要输出</span>        <span class="hljs-keyword">if</span>(a[i] != <span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a[i];</span>            <span class="hljs-comment">//coe精确到小数点后一位</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %.1f&quot;</span>, i, a[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接&lt;/strong&gt;：&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000&quot;&gt;1002 A+B for Polynomials&lt;/a</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="PAT" scheme="https://leungll.site/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>【洛谷 1045 &amp;&amp; 蓝桥杯 算法训练 ALGO - 26】麦森数（二分 + 高精度）</title>
    <link href="https://leungll.site/2020/04/02/mersenne-number-permalink/"/>
    <id>https://leungll.site/2020/04/02/mersenne-number-permalink/</id>
    <published>2020-04-02T14:24:37.000Z</published>
    <updated>2024-05-24T08:20:52.172Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="1-题目">1 题目</span></h2><h2><span id="问题描述">问题描述</span></h2><blockquote><p>形如 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span> 的素数称为麦森数，这时 <span class="markdown-them-math-inline">$P$</span> 一定也是个素数。但反过来不一定，即如果 <span class="markdown-them-math-inline">$P$</span> 是个素数， <span class="markdown-them-math-inline">$2 ^ {P}-1$</span> 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 <span class="markdown-them-math-inline">$P=3021377$</span> ，它有 <span class="markdown-them-math-inline">$909526$</span> 位。麦森数有许多重要应用，它与完全数密切相关。<br>任务：从文件中输入 <span class="markdown-them-math-inline">$P（1000 &lt; P &lt; 3100000）$</span>，计算 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span> 的位数和最后 <span class="markdown-them-math-inline">$500$</span> 位数字（用十进制高精度数表示）</p></blockquote><h2><span id="输入格式">输入格式</span></h2><blockquote><p>文件中只包含一个整数 <span class="markdown-them-math-inline">$P$</span>（1000 &lt; P &lt; 3100000）</p></blockquote><h2><span id="输出格式">输出格式</span></h2><blockquote><p>第一行：十进制高精度数 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span> 的位数。<br>第 2 - 11 行：十进制高精度数 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span> 的最后 500 位数字.（每行输出 50 位，共输出 10 行，不足 500 位时高位补 0 ）<br>不必验证 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span> 与 <span class="markdown-them-math-inline">$P$</span> 是否为素数。</p></blockquote><h2><span id="样例输入">样例输入</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-number">1279</span></code></pre></div><h2><span id="样例输出">样例输出</span></h2><div class="highlight"><pre class="code"><code>38600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010407932194664399081925240327364085538615262247266704805319112350403608059673360298012239441732324184842421613954281007791383566248323464908139906605677320762924129509389220345773183349661583550472959420547689811211693677147548478866962501384438260291732348885311160828538416585028255604666224831890918801847068222203140521026698435488732958028878050869736186900714720710555703168729087</code></pre></div><h2><span id="2-题目分析">2 题目分析</span></h2><p><strong>1. 题目难点：</strong></p><ul><li>求 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span>  的位数</li><li>高精度算法</li><li>二分快速幂实现</li></ul><p><strong>2. 求 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span>  的位数</strong></p><ul><li>首先要知道的是 <span class="markdown-them-math-inline">$2 ^ {P}-1$</span> 与 <span class="markdown-them-math-inline">$2 ^ {P}$</span> 有相同的位数，因此接下来我们直接求 <span class="markdown-them-math-inline">$2 ^ {P}$</span> 的位数</li><li>不妨设 <span class="markdown-them-math-inline">$k\ =\ 2^{p}$</span></li><li>我们知道， <span class="markdown-them-math-inline">$10^{n}$</span> 的位数为 <span class="markdown-them-math-inline">$n+1$</span>，而根据对数运算规则，<span class="markdown-them-math-inline">$10^{\lg 2}\ =\ 2$</span></li><li>因此将 <span class="markdown-them-math-inline">$10^{\lg 2}\ =\ 2$</span> 代入 <span class="markdown-them-math-inline">$k\ =\ 2^{p}$</span> 得<br><div class="markdown-them-math-block">$$k = 10 ^ {\lg 2 * p}$$</div><br>所以 <span class="markdown-them-math-inline">$ 2 ^ {P}$</span> 的位数为 <span class="markdown-them-math-inline">$p*{\lg 2} +1$</span></li><li>另外，C++ 的 cmath 库中<strong>自带 log10() 函数</strong>。也有直接计算位数的函数：<strong>ceil( n 次方 * log10(底数))</strong></li></ul><p><strong>3. 高精度算法</strong></p><ul><li><p>在 C/C++ 中，<span class="markdown-them-math-inline">$int$</span> 类型有 <strong>10 位</strong>，取值范围为：<span class="markdown-them-math-inline">$-2147483648\sim2147483647$</span>；<span class="markdown-them-math-inline">$long\,long$</span> 类型有 <strong>19 位</strong>，取值范围为：<span class="markdown-them-math-inline">$-9223372036854775808\sim9223372036854775807$</span></p></li><li><p>如果有两个 30 位的数字相乘，应该如何用计算机实现？</p></li><li><p>这就是高精度乘法的应用，以高精度加法举例，就是用数组存储数字每一位的数字，逐个运算，具体的算法可参考博客：<strong><a href="https://blog.csdn.net/fanyun_01/article/details/79967170">高精度加、减、乘、除算法实现详解</a></strong></p></li><li><p>在本题中，就是运用<strong>高精度乘法</strong>的原理实现<strong>二分快速幂</strong>过程。</p></li></ul><p><strong>4. 二分快速幂实现</strong></p><ul><li>快速幂原理：<strong><a href="https://leungll.site/2021/05/24/ksm-permalink">https://leungll.site/2021/05/24/ksm-permalink</a></strong></li><li>在本题中，用两个函数实现快速幂中 <strong>ans *= base</strong> 与 <strong>base *= base</strong> 的功能，其中 <span class="markdown-them-math-inline">$p$</span> 则为幂方 <span class="markdown-them-math-inline">$b$</span> ，数组 b[maxn] 为基数 <span class="markdown-them-math-inline">$base$</span></li></ul><h2><span id="3-题解">3 题解</span></h2><div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//乘法开2倍长度</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1001</span>;<span class="hljs-keyword">int</span> ans[maxn], b[maxn], carry[maxn], p;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(carry, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(carry));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">500</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">500</span>;j++)&#123;            carry[i + j - <span class="hljs-number">1</span>] += ans[i] * b[j];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">500</span>;i++)&#123;        carry[i + <span class="hljs-number">1</span>] += carry[i] / <span class="hljs-number">10</span>;        carry[i] = carry[i] % <span class="hljs-number">10</span>;    &#125;    <span class="hljs-built_in">memcpy</span>(ans, carry, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(carry, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(carry));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">500</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">500</span>;j++)&#123;            carry[i + j - <span class="hljs-number">1</span>] += b[i] * b[j];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">500</span>;i++)&#123;        carry[i + <span class="hljs-number">1</span>] += carry[i] / <span class="hljs-number">10</span>;        carry[i] = carry[i] % <span class="hljs-number">10</span>;    &#125;    <span class="hljs-built_in">memcpy</span>(b, carry, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(b));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> p;    cin &gt;&gt; p;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-keyword">int</span>)( p * <span class="hljs-built_in">log10</span>(<span class="hljs-number">2</span>) ) + <span class="hljs-number">1</span>);    <span class="hljs-comment">//赋初值 </span>    ans[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, b[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span>(p)&#123;        <span class="hljs-keyword">if</span>(p % <span class="hljs-number">2</span>)&#123;            <span class="hljs-built_in">fun1</span>();        &#125;        <span class="hljs-built_in">fun2</span>();        p /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-comment">//题目要计算的是2 ^ &#123;P&#125; - 1</span>    ans[<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">500</span>;i &gt; <span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">500</span> &amp;&amp; i % <span class="hljs-number">50</span> == <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, ans[i]);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;1-题目&quot;&gt;1 题目&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span id=&quot;问题描述&quot;&gt;问题描述&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;形如 &lt;span class=&quot;markdown-them-math-inline&quot;&gt;$2 ^ {P</summary>
      
    
    
    
    <category term="算法" scheme="https://leungll.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C/C++" scheme="https://leungll.site/tags/C-C/"/>
    
    <category term="快速幂" scheme="https://leungll.site/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="二分快速幂" scheme="https://leungll.site/tags/%E4%BA%8C%E5%88%86%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="高精度" scheme="https://leungll.site/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
    <category term="求位数" scheme="https://leungll.site/tags/%E6%B1%82%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
</feed>
